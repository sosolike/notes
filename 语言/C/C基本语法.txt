C基本部分：
    1：C语言简介
    2：C语言标准
    3：C程序执行流程
    4：C程序编译器

    一：C语言简介：
        1：C语言属于静态类型编程语言，具有严格的数据类型约束，能够直接对位，字节，内存地址进行操作，属于高级编程语言，但又可以创建偏底层的应用程序；
        2：C源程序在执行之前需要先编译链接为可执行文件；执行程序时需要由操作系统执行该可执行文件；
        3：C语言在编程方式上仅支持面向过程编程，不支持面向对象编程；
        4：相对于动态类型的脚本编程语言：
            优势：C语言由于严格的数据类型约束、提前进行编译链接为二进制的可执行文件、能够直接操作更底层的位，字节，内存地址等特性保证了C程序执行效率较高，并且程序错误会在编译阶段被发现，尽量能够避免执行时发生程序错误；
            劣势：动态类型的脚本编程语言：具有更符合应用场景的库，更简单快捷的编程方式，因此比C语言具有更高的编程效率；
    
    二：C语言标准：
        1：C89和C90标准：
            C89来源：ANSI在1989年批准通过了C语言语法规范以及C语言标准库，因此称之为C89标准或者ANSI C；
            C90来源：ISO在1990年采用ANSI批准通过的C语言语法规范及C标准库，因此称之为C90标准或者ISO C；
            C89标准和C90标准指的是同一个标准；该标准也是编译器支持度最高的标准；
        2：C99标准：
            C89/C90标准发布之后，C语言标准委员会又不断的改进C语言；并最终在1999年开发布了新的C语言标准，并称之为C99标准；
            C99标准引入了许多新的特性：内联函数、可变长度数组、灵活的数组成员、复合字面量、支持不定参数个数的宏定义，在数据类型上还引入了long long int以及复数类型等新特性；
            目前对C99标准的支持在GCC以及Clang都能达到90%以上，但是Visual Studio目前支持度并不是特别高；
        3：C11标准：
            C语言标准委员会在2011年发布了新的C语言标准，称之为C11标准；C11在C99的基础上又引入了字节对齐说明符，泛型机制，对多线程的支持、静态断言、原子操作以及对Unicode的支持等特性；
        4：目前尽量使用C89/C90标准或者C99标准，因为编译器对C11标准的支持程度有限，尽量避免使用；

    三：C程序执行流程：
        基本流程：
            由于C语言是静态类型编程语言，C源程序需要先被编译链接为可执行文件，然后在需要执行时由操作系统执行该可执行文件，由C源程序到可执行文件需要经过以下几个阶段：
                1：编写源程序；
                2：对源程序进行预处理操作，得到预处理文件；
                3：对预处理文件进行编译操作得到汇编文件；
                4：对汇编文件进行汇编操作得到二进制目标文件；
                5：对二进制目标文件链接操作得到二进制的可执行文件；
        详细流程：
            1：编写C源程序：
                1：通过C语言编写C程序文件，一个C源程序由一个或者多个C源文件组成，每一个C源文件都以.c作为后缀，每一个C源文件都由若干个函数和函数外的语句组成；
                2：一个C源程序必须要有且只能有一个主函数，如果C源程序由多个C源文件组成时，主函数可以放置在任意一个C源文件中；

            2：对源程序文件进行预处理，得到预处理文件：
                1：C源程序中一般会有#include包含头文件的代码，以及对宏的使用；将#include包含头文件的代码替换成头文件内容，将代码中的宏替换成宏的值，这个过程即为预处理；
                2：预处理完成之后得到的预处理文件中仍然是C代码，相比C源文件，仅仅只是将包含头文件的代码替换为头文件的内容，将宏替换为宏的值；并且仍然是文本文件；
                3：预处理文件以.i作为后缀；在linux中使用gcc编译器可以通过命令：gcc -E ./a.c -o ./a.i得到预处理文件；
            
            3：对预处理文件进行编译操作，得到汇编文件：
                1：将预处理之后得到的预处理文件编译之后即可得到特定汇编代码组成的文件；
                2：编译完成之后得到的汇编文件是由特定汇编代码组成的，仍然是文本文件；
                3：汇编文件以.s作为后缀，在linux中使用gcc编译器可以通过命令：gcc -S ./a.c -o ./a.s得到汇编文件；
            
            4：对汇编文件进行汇编操作，得到当前C源程序文件的二进制目标文件：
                1：将编译完成后的汇编文件转换成二进制的目标文件的过程称为汇编；
                2：汇编完成之后得到的目标文件是由二进制代码组成的，是二进制文件；
                3：汇编文件以.o作为后缀，在linux中使用gcc编译器可以通过命令：gcc -c ./a.s -o ./a.o得到目标文件；
            
            5：对二进制目标文件链接操作，得到二进制的可执行文件；
                1：一个可执行文件包括四个部分：
                    1：启动代码
                    2：使用到的库函数代码
                    3：当前C源文件汇编得到的目标文件
                    4：组成C源程序的其他C源文件汇编得到的目标文件；
                    上一步汇编完成之后只是得到了一个C当前源文件的目标文件，还缺少启动代码、引用到的库函数代码以及组成C源程序的其他C源文件的目标文件，所以还不能作为可执行文件运行起来；
                2：链接的过程即为将当前C源文件汇编得到的目标文件，启动代码，库函数代码和组成C源程序的其他C源文件的目标文件合并成为一个完整的可执行文件的过程；
                3：可执行文件以.out作为后缀，在linux中使用gcc编译器可以通过命令：gcc -o ./aim.out ./a.o ./b.o得到可执行文件；
                4：链接完成之后即可得到最终的可执行文件，在linux平台上以.out作为后缀，在windows平台上，以.exe作为后缀！由于linux平台对于文件后缀并无要求，因此.out可以省略；
        
    四：C语言编译器：
        Linux上的常用的编译器为：gcc（最终可执行文件的后缀名为.out，windows上的可执行文件后缀为.exe）
    
C语法部分：
    1：C语言语法基本要求
    2：C语言语法内容
    3：C语言标准库
    4：C语言高级部分

    一：C语言语法基本要求：
        1：C源程序的组成：
            1：一个C源程序可以由一个或者多个C源文件组成； 
            2：一个C源程序的每一个C源文件都以.c作为后缀；
            3：每一个C源文件都是由若干个函数以及若干个声明语句(头文件的包含、宏的定义、类型的定义、常量的定义，全局变量的声明、函数的声明、预处理语句)组成；
        
        2：程序执行方式：
            1：C程序执行时，从主函数开始执行，并从主函数结尾，并将执行状态以整数的形式返回给执行环境；
            2：一个C源程序必须要有并且只能有一个主函数；这个主函数可以放在任意一个C源文件中；
            3：源程序必须先编译链接为可执行文件，再由操作系统执行该可执行文件来执行程序；

        3：C主函数：
            1：一个C源程序必须要有，并且只能有一个主函数；
            2：如果一个C源程序由多个C源文件组成，那么主函数可以放在任意一个C源文件中；
            3：C程序执行时，从主函数开始执行，并从主函数结尾处结束执行；并将执行状态以整数的形式传递给执行环境；
            4：主函数的名称只能是main，不能自定义为其他名称；
            5：主函数的定义方式：
                标准定义方式：
                    1：int main(void){/* ... */}
                    2：int main(int argc,char *argv[]){/* ... */}
                非标准定义方式：
                    3：int main(int argc,char *argv[],char *envp[]){/* ... */}
            6：主函数的形参说明：
                1：按照标准方式定义，可以选择以第一种方式声明，即不接受任何参数，直接声明为void；
                2：按照标准方式定义，也可以选择以第二种方式声明，接收两个参数；其中：
                    int argc表示以命令行执行该程序的可执行文件时传入参数的个数；
                        如果没有传递任何参数时，其值为1，因为可执行文件本身的名称也算是一个参数；
                        如果有传入参数时，其值为参数个数+1；
                    char *argv[]：一个字符串数组，每一项都指向使用命令行执行该程序时传入的字符串参数；
                        其中argv[0]表示可执行文件的名称；
                        其余传入的参数可以通过argv[1]~argv[argc-1]获取；
                3：按照非标准形式定义时，会在第二种定义的方式上多一个envp参数，表示执行该可执行文件时的环境信息，若干个字符串，每一个字符串都以键值对的形式表示环境信息；该参数表示的环境信息也可以在程序中通过getenv()标准函数获取；
            7：主函数的执行结果：
                C源程序从主函数开始执行，也从主函数结尾处结束执行；在主函数执行结束后，会将执行状态以整数的形式传递给操作系统；
                1：返回值是0或者EXIT_SUCCESS，表示程序执行一切顺利；成功结束执行！
                2：返回值是任何其他非0值，尤其是EXIT_FAILURE，则表示程序执行时出现问题；并未成功执行完该程序；
                3：mian函数并非必须调用return显式的返回一个整数值，如果程序运行到main()的右' } '处，将会自动向执行环境返回状态值0，如果执行发生异常则将会自动向执行环境返回非0状态值；
                4：main()函数的结束等效于在主线程中调用标准库函数exit(),exit()的参数将会作为main()的返回值；

        4：C代码语法要求：
            1：以;作为语句结束符号；
            2：以{}作为代码块符号；
            3：以//作为单行注释，以/* ... */作为多行注释；
            4：标识符命名规范：
                1：以数字，字母，下划线组成；
                2：不能以数字开头；
                3：不能和关键字冲突；
                4：严格区分大小写；
                5：避免使用_或者__开头；
                6：避免使用拼音和英语混合式命名！
            5：一个C源文件结构上由两部分组成：1：函数、2：函数外部的语句；函数外部的语句只能是以下几种：头文件包含语句，宏的定义，类型的定义，常量的定义，全局变量的声明，函数的声明语句，预处理语句；其余具备运算能力或者逻辑处理能力的语句都必须放在函数内部！

    二：C语言基本语法内容：
        1：C语言输入输出(标准输出)：
            1：输出单个字符：
                putchar();      #如 putchar('c');
            2：输出字符串：
                puts();     #如 puts("string");
            3：打印任意数据类型的数据：
                printf()
                3.1：基本使用格式：
                    printf("format string",data1,data2,data3...);
                3.2：format string的组成：
                    format string由自定义字符和格式化字符组成；自定义字符将会原样打印，格式化字符将会按照顺序对后面的data1、data2等进行格式化，并替换为格式化之后的数据；
                3.3：格式化字符：%[flag][width][.precision][type]
                    flag：
                        -：默认输出是右对齐，带上-之后则为左对齐；
                        +：正数带上+号，负数带上-号；
                        #：对于小数，强制输出小数点，对于八进制，十六进制，二进制，带上前缀；
                        空格：用于数字：正数加空格，负数加负号；
                    width：
                        最小宽度限制；对于字符串，如果字符串字符个数不足将会使用空格补齐，如果字符个数超过最小宽度限制之后，该限制将会自动失效
                    .precision：
                        对于int类型，表示最小输出宽度，不足时将会使用0补齐；
                        对于float、double类型，表示输出精度(小数部位的位数)；
                        对于str类型，表示最大输出宽度；如果字符串长度超过该限制将会截取字符串；
                    type：
                        表述被格式化的数据需要被格式化为何种数据类型：
                        字符/字符串：
                            %c          //格式化成字符类型
                            %s          //格式化成字符串类型
                        浮点数：
                            %f          //格式化成单精度(float)类型的小数形式
                            %lf         //格式化成双精度(double)类型的小数形式
                            %e          //格式化成单精度(float)类型的指数形式
                            %le         //格式化成双精度(double)类型的指数形式
                            %E          //格式化成单精度(float)类型的指数形式(以大E表示)
                            %lE         //格式化成双精度(double)类型的指数形式(以小e表示)
                        十进制整数：
                            %d          //格式化成十进制、有符号、int类型整数
                            %hd         //格式化成十进制、有符号、short类型整数 
                            %ld         //格式化成十进制、有符号、long类型整数
                            %u          //格式化成十进制、无符号、int类型整数
                            %hu         //格式化成十进制、无符号、short类型整数 
                            %lu         //格式化成十进制、无符号、long类型整数
                        八进制整数：
                            %o          //格式化成八进制、无符号、int类型整数
                            %lo         //格式化成八进制、无符号、long类型整数
                            %ho         //格式化成八进制、无符号、short类型整数
                        十六进制整数：
                            %x          //格式化成十六进制、无符号、int类型整数
                            %lx         //格式化成十六进制、无符号、long类型整数
                            %hx         //格式化成十六进制、无符号、short类型整数
            4：打印单个宽字符：                
                putwchar()：只能输出单个宽字符，且要使用setlocale(LC_ALL,"zh_CN");来设置本地化
            5：打印宽字符串：
                wprintf()：用于输出宽字符串
                           宽字符标识：%ls;
                           用法：和printf完全一样

        2：C语言变量：
            1：C语言中变量使用基本要求：
                1：C语言中变量使用之前必须先声明，后使用；
                2：声明变量时，必须指明变量的数据类型，变量名称，如有必要可以赋上初始值；
                3：变量声明时，即确定该变量的数据类型；在程序运行过程中，变量只能指向和其数据类型相同的数据，不能指向其他数据类型的数据；

            2：C语言中变量命名规范：
                1：C语言变量名必须遵守C语言标识符命名规范；
                2：C语言变量推荐采用小写+ '_' 分割式命名；如：var_name
            
            3：C语言中使用变量：
                C语言中的变量由两种类型：全局变量和局部变量；
                1：全局变量：在函数外部声明的变量称之为全局变量；
                    1：声明位置：在函数外部声明；
                    2：初始值：
                            1：如果在声明全局变量的同时赋予该变量初始值，那么该变量的初始值即为设置的值；
                            2：如果声明的同时未赋值：
                                那么对于int类型的变量其初始值为0；
                                指针类型的初始值为null；
                                浮点数类型的初始值为：0.000000；
                                字符串类型的初始值为"";
                    3：注意事项：
                        在函数外部只能进行全局变量的声明，不允许进行变量的运算，赋值，打印等其他操作；
                    4：全局变量的类型：
                        全局变量按照声明方式的不同，分为普通全局变量和静态全局变量：
                    5：普通全局变量：
                        1：声明方式：数据类型 变量名 = 初始值;
                        2：作用域：普通全局变量的作用域为组成该C源程序的所有源文件，即不允许在不同的源文件中出现同名的普通全局变量；
                        3：特性：普通全局变量可以在其他源文件中使用 extern引入；引用方式：extern 数据类型名 普通全局变量名
                    
                    6：静态全局变量：
                        1：声明方式：static 数据类型 变量名 = 初始值;
                        2：作用域：静态全局变量的作用域仅在当前源文件中；即允许在不同的源文件中出现同名静态全局变量；
                        3：特性：静态全局变量的作用域仅在当前源文件中，因此不允许在其他源文件中引入其他文件中的静态全局变量；
                
                2：局部变量：在函数内部声明的变量称之为局部变量：
                    1：声明位置：
                        对于c89/c90规定，在任何执行语句之前，在块的开头声明所有局部变量；
                        对于c99和c++中则没有这个限制，局部变量声明可以放在首次调用之前的任意位置；
                    2：初始值：
                        对于局部变量，其声明时如果没有给定初始值，那么其初始值是不确定的，无论是何种数据类型的局部变量，只要未给定初始值，其初始值就是不确定的；
                    3：局部变量的类型：
                        局部变量根据声明的方式分为自动局部变量和静态局部变量；
                    4：自动局部变量：
                        1：声明方式：数据类型 变量名 = 初始值;   或者  auto 数据类型 变量名 = 初始值;
                        2：作用域：仅限当前函数中，声明语句之后使用；
                        3：生命周期：自动局部变量的生命周期和其所在的函数一致，函数被调用时对该局部变量进行初始化，函数调用完成之后该局部变量即被销毁，下次调用该函数时重复上述流程；
                        4：自动局部变量如果不赋初值，其值是无意义的不确定的；
                    5：静态局部变量：
                        1：声明方式：static 数据类型 变量名 = 初始值; 
                        2：作用域：仅限当前函数中，声明语句之后使用；
                        3：生命周期：静态局部变量的生命周期和应用程序一致，函数首次被调用时对该静态局部变量进行初始化，函数调用完成之后该静态局部变量并不会被销毁，下次调用该函数时该函数将不再重新声明和初始化，其值为上次函数调用完毕之后最后一次对该变量的修改；
                        4：静态局部变量如果不赋初值，其值是无意义的不确定的；

        3：C语言常量：
            常量即为值不能修改的量，C语言中通过const关键字创建一个常量或者将变量修饰为常量；
            1：常量使用方式：
                1：通过const关键字创建一个常量：const 数据类型 常量名 = 值；
                2：通过const关键字将变量修饰为一个常量：const 变量名；
                3：通过const关键字将函数参数修饰为一个常量：const 数据类型 形参名称；
            
            2：常量使用时的注意事项：
                1：通过const创建常量时，必须在创建的同时对常量进行初始化，否则将无法再对常量赋值；
                2：通过const修饰变量为常量时，在修饰完成之后，该变量将不能在重新赋值；
                3：对于函数形参，如果为了防止函数内部对形参做了修改，可以将形参修饰为常量；
            
            3：const在修饰不同数据类型时有不同的结果：
                1：对于基本类型数据(int float)：使用const修饰之后，该变量本身将不能再重新赋值；
                2：对于指针类型数据：使用const修饰时有以下三种情况：
                    const char * uname;   
                    此时const修饰的是指针所指向的内存空间，因此uname指向的内存地址中存储的数据不允许再被修改，但是指针本身可以指向其他内存地址；

                    char * const uname;
                    此时const修饰的是指针变量本身，因此uname指向的内存地址中不允许再被修改，即该指针不能再指向其他内存地址，但是指针指向的内存空间中存储的数据被修改；

                    const char * const uname;
                    此时const既修饰指针变量本身也修饰指针变量所指向的内存空间，因此uname指向的内存地址中不允许再被修改，即该指针不能再指向其他内存地址，并且指针指向的内存空间中存储的数据也不允许再被修改；

        4：C语言运算：
            1：符号类型运算：
                1：()：
                     表示优先执行()中的语句；
                2：*：
                    用在非声明场景下表示取值符，表示获取一个指针变量所指向的内存空间中的数据；
                    用在声明场景下表示紧跟 * 后面的变量为指针变量；
                3：&：
                    用在单运算时表示取地址符，表示获取一个变量的内存地址；
                    用在双运算时表示按位与运算；
                4：[]：
                    表示在紧跟在[]之前的变量表示的是一个数组；
                
            2：符号类型运算级别：
                ()运算优先级最高，任何情况下都先执行()中的语句；
                []作为后缀运算符，其优先级仅此于();
                *和&(表示取地址符时)作为前缀运算符，其优先则低于后缀运算符[]；
            
            3：数值类型运算：
                1：算术运算：+ - * / % ++ --
                    使用范围：只能适用于数字
                    运算方向：从左至右运算
                    级别：仅次于逻辑运算中的' ! '，大于关系运算
                    备注： 
                        对于除法：
                            如果除数和被除数都是整数，那么得到的结果也是整数；
                            如果除数和被除数有一个是小数，那么得到的结果也是小数；并且是double类型的小数；
                        对于取余运算：
                            C语言中的取余运算只能针对于整数进行，即%两边都必须是整数，否则编译器将会报错！
                        对于自增自减运算：自增/自减运算在和赋值运算一起进行的时候需要注意前后位置关系：
                            前自增在赋值时先运算后赋值；
                            后自增在赋值时先赋值后运算；
                
                2：比较运算：< > <= >= == !=
                    运算方向：从左至右
                    级别：整体级别大于逻辑运算符的&&和||，小于算术运算符，但是同级别内< > <= >=的级别高于==和!=；
                
                3：逻辑运算：&& || ！
                    运算方向：从左至右
                    级别：&& 和 || 小于关系运算符，！小于()大于算术运算符
                    运算结果：运算结果是一个Bool值

                4：赋值运算：= += -= *= /= %= 
                    方向：将右侧的值赋给左侧
                    级别：级别最低；
                
                5：6种位运算：& | ^ ~ << >>
                    &：
                        按照二进制位求与运算，两个二进制位都为1才为1，只要有一个为0即为0；
                    |：
                        按照二进制位求或运算，两个二进制位一个为1即为1，两个都为0时才为0；
                    ^：
                        按照二进制位求异或运算，如果两个二进制位的值不同即为1，否则即为0；
                    ~：
                        按照二进制位取反：获取某个数值的补码；
                    <<:
                        按照二进制位全部左移，高位丢弃，低位补0；如x<<y：x数值向左移动y位；左移 y 位相当于乘以 2 的 y 次方;
                    >>：
                        按照二进制位全部右移，如果左侧操作数是无符号类型或者是有符号类型，但是为非负值，则右移时左侧多出了的位直接补0，该情况下右移y位等效于除以2的y次方；如果左侧是负值，则由编译器确定左侧是补充0还是符号位，如果是补充符号位依然等效于除以2的y次方，但是如果是补0，则不等效；
                    注意：
                        1：参与位运算的必须是整数；
                        2：参与移动位运算的两侧数值必须都是整数；右侧的数值不能为负值，并且不能超过左侧数据的位长；
            4：数值类运算级别：
               符号类型运算 > ! > 算术运算 > 关系运算 > &&和|| 
               移位运算符的优先级高于比较运算符和其他位运算符，但是低于算数运算符；

        5：C语言流程控制：
            1：条件控制：
                1：if..else条件语句：
                    if(表达式)
                    {

                    }
                    --------------------------
                    if(表达式)
                    {

                    }else if(表达式)
                    {

                    }else{

                    }
                    --------------------------
                    if(表达式)
                    {

                    }else{

                    }
                2:switch条件语句：
                    switch(var){
                        case 1:
                            code..
                            break;
                        case 2:
                            code..
                            break;
                        default:
                            code...
                    }
                    备注： 
                        1：switch中只能是整数，不能是浮点数或者其他数据类型；
                        2：case只能是整数，不能是浮点数或者其余数据类型；
                        3：多个分支有共同处理方式，则多个分支可以放在一起，只在最后一个分支结束时使用break语句；
                        4：default不是必须的；当所有的case都无法匹配时，将会走进default;
                        
                3：? :   三目运算符；int a= b>0 ? b : 0

            3：循环控制：
                for(int i=0;i<n;i++)
                {

                }
                --------------------------
                while(表达式)
                {

                }
                --------------------------
                do
                {

                }while(表达式);(;一定要有)

            4：跳出循环：
                1：break;结束当前循环；
                2：continue;结束当前循环，并开始新的循环！
        6：C语言基本数据类型：
        7：C语言基本数据类型转换：
        8：C语言复杂数据类型：
            指针：
                1：存储单元和内存地址：
                    1：CPU处理数据时，数据必需先加载至内存中，才能够被CPU访问；
                    2：而内存的物理实体就是内存条，内存在操作系统中会被分割为若干个1字节大小的存储单元，每一个存储单元都会有一个编号，这个编号称之为存储单元的地址或者内存地址；通过这个地址即可向存储单元中存储数据，或者从该存储单元中获取数据；
                    3：由于一个存储单元只有1个字节大小，因此在声明变量时，系统将会按照变量的数据类型在当前系统所占用的字节个数，来分配若干个连续的存储单元作为一个内存块给该变量使用；
                    4：存储单元的地址从0开始编号，并以16进制表示；数据类型为unsigned int;
                2：对于指针的理解：
                    从概念上来看：指针类似一个箭头，指向某个存储单元，这个箭头是虚拟的，并不真实存在；
                    从编程上来看：指针表示的就是某个存储单元，在程序中的具体体现就是指针变量，指针变量的值即为某个存储单元的地址；通过指针变量的值即可确定某个存储单元的地址，进而通过该地址访问存储单元中的内容；
                3：指针和数据的理解：
                    1：数据是指存储在存储单元中的内容；可以为任何数据类型；
                    2：指针表示的是某个存储单元，在程序中的具体表现形式是指针变量，指针变量的值是某个存储单元的地址，通过指针即可访问某个存储单元中的内容；指针变量的值即存储单元的地址数据类型固定为unsigned int类型；
                4：指针变量和普通变量的区别：
                    1：意义不同：
                        1：指针变量是指针在程序中的具体体现，其值表示的是存储单元的地址，类型固定为unsigned int；以十六进制表示；
                        2：普通变量代表的是具体的数据，其值是存储单元中的内容；类型在声明变量时确定；
                    2：数据类型不同：
                        1：指针变量的数据类型固定位unsigned int 类型；
                        2：普通变量的数据类型则在声明时确定；
                    3：运算方式不同：
                        1：指针变量在运算时本质上是改变指针对存储单元的指向；
                        2：普通变量在运算时本质是存储单元中内容的修改；
                    注意：
                        1：本质上指针变量和普通变量并没有任何区别，都代表的是数据，只是指针变量代表的数据表示的是某个存储单元的地址，而普通变量表示的数据是某个存储单元的内容；
                        2：虽然指针变量的数据类型为unsigned int，但是不允许将指针变量和数据类型为unsigned int的普通变量进行运算；因为两个变量表示的意义不同，系统在处理时的方式也不同；
                        3：指针变量的值本身也是需要存储在存储单元组成的内存快中，因此存储指针变量值的存储单元同样也是可以被其他指针指向的；
                5：指针变量的声明：
                    1：声明方式：
                        数据类型 * 变量名 = 初始值; 
                            或者  
                        数据类型 *变量名 = 初始值;
                    2：指针变量声明说明：
                        1：数据类型：表示的是指针指向的存储单元组成的内存块中要存储的数据的数据类型；系统将会按照数据类型分配若干个连续的存储单元；一旦声明完成之后，该指针指向的若干个存储单元将只能存储指定数据类型的数据；
                        2：*可以和变量间隔一个空格也可以紧挨着变量，在声明场景下，*表示紧跟其后的变量是一个指针变量；
                        3：指针变量的命名和普通变量的命名规范一致；
                6：指针的运算：
                    1：&：该运算是取地址符；该运算符可以使用在普通变量和指针变量之前，用来获取变量的内容在内存中的地址，即变量的内容所占用的内存块首个存储单元的地址；
                    2：*：该运算符是取值符，可以通过*获取指针指向的存储单元中所存储的值；
                    3：通过指针变量向内存中设置值：*指针变量 = 值；
                    4：指针变量允许和同类型的指针变量之间互相赋值：赋值完成之后，两个指针变量指向同一个存储单元；(参与赋值的两个指针变量必须数据类型相同)；
                    5：指针变量可以参与算数运算：指针变量允许加上或者减去一个整数或者对指针变量进行自增自减运算，来改变指针对存储单元的指向；
                    6：对于指针变量加减整数或者自增自减运算说明：
                        1：普通变量加减某一个整数是指给存储单元中存储的数据本身加/减去n，不会引起数据在内存中存储地址的改变；
                        2：指针变量加减某个整数m或者自增自减运算:
                            微观上看：指针变量加/减某个整数m，是指将指针变量的指向跳过n*m个存储单元，n是指当前指针变量数据类型在当前平台所占字节个数；
                            宏观上看：指针变量的加减运算改变的是当前指针对存储单元的指向；
                        3：不允许对指针变量做除过加减一个整数/自增自减以外的任何其他算术运算；
                        4：普通的指针变量做自增自减或者加减运算并无任何实际意义；指针的指向会改变，但是指向新的存储单元中的数据则是不确定的；
                        5：对于数组或者字符串,由于其占用的是一段连续的存储单元，因此指针变量的加减/自增自减改变的是指针指向的元素位置，其值是可以预料的，通过对指针位置的改变可以获取到相邻的元素值，是有意义的；
                7：空指针：
                    1：在函数中声明一个指针变量但是并不初始化，那么该指针变量的值是不确定的，因此该指针的指向也是不确定的，一般情况下都是指向一个无读写权限的地址，将会造成程序的隐患；
                    2：建议在函数中声明指针变量时对其初始化，如果不知道指针变量的初始值，可以将指针变量的值设置为NULL；即把该指针设置为一个空指针；C语言并未规定空指针的指向，但是大多数编译器将空指针指向地址为0的存储单元，并且其类型未知；
                    3：对于指针而言，在除过赋值类型的操作以外，要先检测，后操作；严禁对空指针进行赋值以外的操作；

                8：二级指针：
                    1：如果指针指向的内存存储的是普通数据，那么该指针称为一级指针，指向存储一级指针变量值的内存的指针称之为二级指针，以此类推三级指针等；
                    2：二级指针以上，无论是几级指针，都是普通的指针，都是指向一个存储单元，仅仅只是其指向的内存中存储的内容是另一个指针变量的值而已；
                    3：无论是几级指针变量，都表示一个普通的变量，其值都是一个unsigned int 类型的数据，其值都表示一个存储单元的地址；
                    4：一级指针变量需要使用*来声明，需要使用*来取值；二级指针变量需要使用**来声明，需要使用**来取值；三级四级依次类推；对于二级指针使用*来取值得到的是以及指针的地址，需要对该地址再次取值运算才能得到最终的值。多级指针原理相同；


            数组：
                1：数组的基本概念：
                    1：数据的有序集合称之为数组
                    2：数组中的每一个值称为数组的元素
                    3：数组中元素的个数称之为数组的长度
                    4：数组中元素按照顺序排列，每一个序号可以唯一确定一个数组元素，因此可以通过元素的序号访问数组元素；
                
                2：数组的声明方式：  
                    1：数组是一个数据容器，在使用之前需要先声明才能使用；
                    2：数组的声明方式：数据类型 数组名[数组长度];
                    对数组声明的几点说明：
                        1：数组声明时就要确定数组的长度，声明时确定的长度即为数组最多容纳的元素数量；一旦声明完成，该长度不允许再被改变，存储数组元素也不允许超过做大限制，否则将会溢出；
                        2：数组声明时即确定数组元素的类型，一旦声明完成，数组中只能存储指定数据类型的数据；不允许存储其他类型的数据；
                        3：对于数组而言，在函数内部声明数组时，如果声明完成后未初始化，那么数组中的元素则是不确定的；
                        4：[]符号为数组符号，表示其之前的紧跟的变量为数组；属于后缀符号，在符号优先级中仅次于()，高于取地址运算符&和取值运算符*;
                        5：数组名称需要符合C语言标识符命名规范；
                
                3：数组的赋值：
                    1：数组可以在声明的同时完成赋值：
                        1：完全赋值：给所有数组元素都赋上初值；
                                    如：int arr[3] = {1,2,3}
                                备注：
                                    1：完全赋值时数组可以不用显式指定长度；
                                        如：int arr[] = {1,2,3}

                        2：不完全赋值：赋值的个数少于数组声明时指定的个数；
                                    如：int arr[3] = {1}
                                备注：
                                    1：不完全赋值时，必须明确表示数组的长度；
                                    2：不完全赋值时，数组未赋值的部分也会按照基本规则进行初始化：
                                        1：如果数组类型为：int,short,long,将直接赋值为整数0；
                                        2：如果数组类型为：char,将赋值为\0；
                                        3：如果数组类型为：float或者double，则将会赋值为0.0；
                    2：数组也可以在声明完成之后进行赋值：
                        数组在声明完成之后只能通过下标一个一个对单个数组元素进行赋值，不能再使用{}整体进行赋值;

                4：对于数组的理解：
                    1：数组是占用一段连续的存储单元来存储数组元素的，这段连续的存储单元的长度为当前数组元素的数据类型在当前平台占据的字节个数m*数组声明时的长度n；
                    2：数组元素在赋值的时候只能赋值数组声明的数据类型的值，不能赋值其他数据类型的值；
                    3：C语言中数组是静态数组，即长度一旦声明好之后将不能再改变，插入数据的个数不能超过长度，否则将会出现溢出；
                    4：固定长度的数组是在编译期间分配内存的；
                
                5：二维数组：
                    1：二维数组的理解：
                        在形态上：二维数组类似于一个矩阵，一维长度指该矩阵的行数，二维长度指该矩阵的列数；
                        在存储上：二维数组仍然是按照一维线性存储，每一行紧挨着上一行存储；
                        在元素上：二维数组类似于一个包含了若干个一维数组的一维数组；
                    2：二维数组的声明：
                        数据类型 数组名[一维长度][二维长度];
                    3：二维数组形态上的理解：
                        1：二维数组在组成结构上类似与一个矩阵，一维长度指该矩阵的行数，二维长度指该矩阵的列数；
                        2：数组元素可以通过一维行数和二维列数唯一确定；
                    4：二维数组存储上的理解：
                        1：虽然二维数组在形态上类似于一个矩阵，但是在实际存储时，仍然是一维线性存储的，即一行挨着一行存储；
                    5：二维数组在元素上的理解：
                        1：二维数组可以看做一个矩阵，那么每一行数据都可以看做一个一维数组，此时一个二维数组可以看做是一个由若干个一维数组作为元素组的一维数组；
                    6：二维数组的赋值：
                        1：分段赋值：按照二维数组的行数赋值
                            1：完全赋值：每一行都完全赋值,虽然是完全赋值，但是一维的长度一定要给出；   
                                        int a=[3][2] = {{1,2},{3,4},{5,6}}
                            2：部分赋值：每一行都只赋值一部分，默认从左向右赋值，其余未赋值的部分则按照数据类型自动填充；
                                        int a[2][4] = {{1,2},{3}}   会自动填充为:{{1,2,0,0},{3,0,0,0}}

                        2：连续赋值：按照一维的方式赋值，并且系统会按照二维的长度自动分行
                            1：完全赋值：从左向右按行赋值；此时可不必给出一维长度，系统会按照二维的长度自动分行；
                                int a[][2] = {1,2,3,4,5,6}   会自动分行为:{{1,2},{3,4},{5,6}}
                            2：部分赋值：从左向右按行赋值；其余则按照数据类型填充；
                                int a[3][2] = {1,2,3}   会自动分行为:{{1,2},{3,0},{0,0}}
                        
                        3：二维数组在声明完成之后赋值，只能按照数组元素一个一个赋值；不允许再整体赋值；
                    7：二维数组的数组名：
                        1：二维数组的首地址：
                            由于二维数组可以看做由若干个一维数组组成的一个大的一维数组；所以二维数组的首地址本质上是第一行元素组成的一维数组的首地址的地址；
                        2：二维数组的数组名：
                            和一维数组的数组名相同，在sizeof()和&取地址运算符以及定义数组时表示的是整个二维数组，除此之外表示的是二维数组的首地址；
                        3：二维数组名表示二维数组首地址时的本质：
                            二维数组的数组名表示二维数组首地址时本质上是一个二级指针，指向第一行元素组成的数组的首地址；即：*二维数组名 即可得到第一行元素组成的数组的首地址(注意是第一行元素组成的数组的首地址，不是第一行元素组成的数组的第一个元素)；
                        4：二维数组指针：
                            是指指向二维数组中某一行的指针，本质上仍然是个二级指针；指向二维数组中的某一行的首地址；
                        5：二维数组指针的声明：
                            数据类型 (*指针变量名)[第二维长度] = 二维数组名; 即可
                        再说明：
                            二维数组指针指向的是二维数组中某一行的首地址，并非二维数组中的某一行；
                            二维数组名表示二维数组首地址的时候，同样指的是二维数组第一行的首地址，而非二维数组的第一行；
                6：数组与指针：
                    1：数组占用的是一段连续的存储单元，占用存储单元的个数为当前数组中元素的数据类型在当前平台占用的字节个数*数组的长度；每一个元素占用的存储单元个数为当前元素在当前平台占用的字节个数；数组中的元素按顺序排列，每一个元素都有确定的序号和存储位置；
                    2：数组名：
                        1：数组名仍然是一个变量，既可以代表整个数组，也可以代表数组中首个元素的内存地址，即数组的首地址；
                        2：C语言中在&运算符、sizeof运算符、数组声明时数组名代表整个数组，除上述三种情况以外，数组名均代表数组的首地址；当数组名表示数组首地址时，数组名本质上是一个指针变量；
                    3：数组指针：
                        1：指向数组某个元素的指针称之为数组指针；数组指针和普通指针并无任何区别，仅仅只是数组指针指向的内存中存储的是某个数组中的某个元素而已；
                        2：数组指针指向数组中的某个元素，仅仅只能代表其指向的元素，即使其指向的是数组的首个元素，也不能代表整个数组；
                        3：由于数组占用的是一段连续的存储单元，每一个元素的位置已经唯一确定，因此对数组指针向前向后移动也能够明确移动之后的指针指向哪一个元素，因此除过通过数组序号以外也可以通过数组指针的增减来访问数组元素；

                7：数组的基本操作：
                    1：获取数组长度：
                        int len = sizeof(数组名)/sizeof(数组元素类型)
                        注意：
                            1：此种方式计算数组长度时，数组名必须代表的是整个数组，不能是指向第一个元素的数组指针；
                            2：如果函数要求传入数组类型的数据，此时如果传入数组名则仅仅代表的是数组的首地址，并不能代表整个数组，根据传入的数组名也无法使用sizeof来计算数组的长度，数组长度需要单独传入；
                    2：数组的取值：
                        1：通过数组名访问：数组名[下标]
                        2：通过指针的方式访问：*(数组名+下标)
                        3：通过数组指针访问：*(数组指针+n)

                    3：数组的赋值：
                        1：通过数组名赋值：数组名[下标] = 值
                        2：通过指针的方式赋值：*(数组名+下标) = 值
                        3：通过数组指针赋值：*(数组指针+n) = 值 

                8：指针数组：
                    1：指针数组是指数组的每一项都代表一个指针；本质上和普通的数组并无区别！

                    2：指针数组的声明方式：
                        1：数据类型名 *数组名[数组长度]
                        2：数据类型名 *(数组名[数组长度])
                        3：注意安装符号运算优先级，后缀运算符的优先级高于前缀运算符，因此*后面的括号可以不用带；

                    3：数组指针和指针数组的区别：数组指针指的是指向数组中某一个元素的指针；指针数组是一个数组，只是数组的每一项都是一个指针！

                    4：对于指针数组声明方式的理解：
                        指针数组的声明方式为：数据类型名 *数组名[数组长度]；
                        1：根据C语言中的运算优先级规则来看，[]后缀运算符的优先级大于前缀运算符*，所以，先根据数组名之后的[]确定该变量是一个数组，在根据数组名之前的*以及数据类型来确定数组中的元素是指定数据类型的指针；
                        2：由于后缀运算符[]的优先级大于前缀运算符*；因此()可以有也可以没有；

                    5：指针数组名的理解：和普通数组一样，在声明、&、sizeof()运算符中代表的是整个数组，即代表数组中的每一个元素；除此之外，指针数组名代表指向第一个数组元素的地址，由于第一个元素也是指针，所以指针数组名此时代表的则是二级指针；   


            字符串： 
                1：C语言中的字符串：
                    1：C语言中使用""来表示一个字符串，但是并没有字符串类型来表示一个字符串；在C语言中通过字符数组来保存字符串中的每一个字符；
                2：字符串的创建和初始化：
                    1：通过字符数组的方式创建：字符串在C语言中本就是以字符数组的方式存储，所以可以通过字符数组的方式创建字符串：
                        1：创建方式：
                            char str[n]      #创建一个具有n个字符的字符串；
                        2：赋值：
                            1：按照数组的方式赋值，可以完全赋值，也可部分赋值：
                                char str[3] = {'s','t','r'}或char str[] = {'s','t','r'}
                            2：按照字符串的方式赋值，可以直接赋值为字符串常量：
                                char str[3] = {"str"}或char str[] = {"str"}或char str[] = "str"
                            3：字符串以数组的方式声明，一旦声明完成之后赋值，将只能按照字符一个一个赋值，不允许再整体赋值；
                        3：字符串的存储位置：
                           以字符数组的方式声明的字符串，无论以何种方式初始化，都是在全局区域保存，具备读写权限，即可以对创建的字符串本身修改；

                    2：通过字符指针的方式创建：
                        1：创建方式：char *str
                        2：赋值：
                            1：按照数组的方式初始化：char *str = {"string"}
                            2：按照字符串的方式初始化：char *str = "string"
                        3：字符串的存储位置：
                            以指针的方式声明的字符串，只能以""的方式初始化，并且该字符串存放在常量区，只具有可读权限，因此一旦声明完成将不能再对字符本身进行修改；
                3：字符串不同声明方式的异同：
                    1：存储区域不同：
                        1：如果字符串以字符数组 char srt[n]的方式创建，那么该字符串是保存在全局数据区，可读可写，即可以对字符串本身进行修改；
                        2：如果字符串以字符指针 char *str的方式创建，那么本质上是创建了一个字符串常量，存放在常量区，只具有可读权限，即不能对字符串本身进行修改；
                    2：字符串名称意义不同：
                        1：如果字符串以字符数组 char srt[n]的方式创建，那么字符串变量名和字符数组名完全相同；即：在&运算符、sizeof运算符、字符数组声明时，字符串变量名代表的是字符串整体；其余情况均只能代表字符串首个字符的地址；
                        2：如果字符串以字符指针 char *str的方式创建，那么字符串本身以及字符串变量名均只能代表字符串首个字符的地址；即此时字符串本身以及字符串变量名都是个指针，指向字符串首个字符；并不能代表字符串整体；
                    3：实际保存时字符串内容不同：
                        1：如果字符串以字符数组 char srt[n]的方式创建时，字符数组中的字符数和创建的字符串字符数完全相同；
                        2：如果字符串以以字符指针 char *str的方式创建，那么实际保存字符串时会在字符串后面加一个'\0'来作为字符串的结束符号；实际保存该字符串数组的字符个数比字符串本身多1个字符；
                4：访问字符串中的字符：
                    1：数组的方式获取字符串中的字符：str1[0]; 或者：str6[n];
                    2：指针的方式获取字符串中的字符：*str1;   或者：*(str1+n);  
                5：字符串的长度：
                    1：使用sizeof(字符数组名)来查询字符串长度：
                        1：如果以字符数组的方式声明，则sizeof的值即为字符串字符个数；
                        2：如果以字符指针的方式声明，则sizeof的值为字符串字符个数+1(原因是：C语言中会在字符串后加上'\0'作为字符串的结束符号)：
                    2：使用string.h头文件中定义的strlen(字符数组名/字符串变量名)函数，该函数计算得到的长度则是字符串的实际长度！其余针对字符串操作的函数也是在string.h头文件中；
                6：对于字符串数组的理解：
                    1：字符串数组声明：char *str[]={"string1","strign2"}中：
                        第一问：为何需要声明成char *str[] 这种格式：
                            1：从指针方面理解：字符串本身以及字符串变量名本质上是一个指针，是指向字符串中首个字符的指针；因此字符串数组本质上是一个指针数组；等价于：
                                char * str_item1 = "string1";
                                char * str_item2 = "string2";
                                char *str[] = {srt_item1,str_item2};
                            所以：char *str[]代表声明一个字符指针数组；

                            2：从字符数组方面理解：字符串本质上都是一个字符数组，因此字符串数组本质上也可以看做是一个二维字符数组；等价于：
                                char str_item1[] = {'s','t','r','i','n','g','1','\0'}
                                char str_item2[] = {'s','t','r','i','n','g','2','\0'}
                                char *str[] = {str_item1,str_item2};
                            所以：char *str[] 代表声明一个二维字符数组；
                        
                    2：注意字符串数组声明：
                        char *str[] 指的是声明一个字符串数组；
                        char (*str)[] 指的是声明一个字符串数组指针，即二维字符数组指针，指向字符串数组中的某一个字符串的地址；

        9：C语言数据类型别名：
        10：C语言函数：
        11：C语言预处理：
        12：C语言错误处理：
        13：C语言断言：
        14：C语言可变参数：

    三：C语言标准库：

    四：C语言高级部分：
        1：C语言多文件编程
        2：C语言文件操作
        3：C语言内存操作
        4：C语言多线程编程
        5：C语言多进程编程
        6：C语言网络编程
       

