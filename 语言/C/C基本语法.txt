C基本部分：
    1：C语言简介
    2：C语言标准
    3：C程序执行流程
    4：C程序编译器

    一：C语言简介：
        1：C语言属于静态类型编程语言，具有严格的数据类型约束，能够直接对位，字节，内存地址进行操作，属于高级编程语言，但又可以创建偏底层的应用程序；
        2：C源程序在执行之前需要先编译链接为可执行文件；执行程序时需要由操作系统执行该可执行文件；
        3：C语言在编程方式上仅支持面向过程编程，不支持面向对象编程；
        4：相对于动态类型的脚本编程语言：
            优势：C语言由于严格的数据类型约束、提前进行编译链接为二进制的可执行文件、能够直接操作更底层的位，字节，内存地址等特性保证了C程序执行效率较高，并且程序错误会在编译阶段被发现，尽量能够避免执行时发生程序错误；
            劣势：动态类型的脚本编程语言：具有更符合应用场景的库，更简单快捷的编程方式，因此比C语言具有更高的编程效率；
    
    二：C语言标准：
        1：C89和C90标准：
            C89来源：ANSI在1989年批准通过了C语言语法规范以及C语言标准库，因此称之为C89标准或者ANSI C；
            C90来源：ISO在1990年采用ANSI批准通过的C语言语法规范及C标准库，因此称之为C90标准或者ISO C；
            C89标准和C90标准指的是同一个标准；该标准也是编译器支持度最高的标准；
        2：C99标准：
            C89/C90标准发布之后，C语言标准委员会又不断的改进C语言；并最终在1999年开发布了新的C语言标准，并称之为C99标准；
            C99标准引入了许多新的特性：内联函数、可变长度数组、灵活的数组成员、复合字面量、支持不定参数个数的宏定义，在数据类型上还引入了long long int以及复数类型等新特性；
            目前对C99标准的支持在GCC以及Clang都能达到90%以上，但是Visual Studio目前支持度并不是特别高；
        3：C11标准：
            C语言标准委员会在2011年发布了新的C语言标准，称之为C11标准；C11在C99的基础上又引入了字节对齐说明符，泛型机制，对多线程的支持、静态断言、原子操作以及对Unicode的支持等特性；
        4：目前尽量使用C89/C90标准或者C99标准，因为编译器对C11标准的支持程度有限，尽量避免使用；

    三：C程序执行流程：
        基本流程：
            由于C语言是静态类型编程语言，C源程序需要先被编译链接为可执行文件，然后在需要执行时由操作系统执行该可执行文件，由C源程序到可执行文件需要经过以下几个阶段：
                1：编写源程序；
                2：对源程序进行预处理操作，得到预处理文件；
                3：对预处理文件进行编译操作得到汇编文件；
                4：对汇编文件进行汇编操作得到二进制目标文件；
                5：对二进制目标文件链接操作得到二进制的可执行文件；
        详细流程：
            1：编写C源程序：
                1：通过C语言编写C程序文件，一个C源程序由一个或者多个C源文件组成，每一个C源文件都以.c作为后缀，每一个C源文件都由若干个函数和函数外的语句组成；
                2：一个C源程序必须要有且只能有一个主函数，如果C源程序由多个C源文件组成时，主函数可以放置在任意一个C源文件中；

            2：对源程序文件进行预处理，得到预处理文件：
                1：C源程序中一般会有#include包含头文件的代码，以及对宏的使用；将#include包含头文件的代码替换成头文件内容，将代码中的宏替换成宏的值，这个过程即为预处理；
                2：预处理完成之后得到的预处理文件中仍然是C代码，相比C源文件，仅仅只是将包含头文件的代码替换为头文件的内容，将宏替换为宏的值；并且仍然是文本文件；
                3：预处理文件以.i作为后缀；在linux中使用gcc编译器可以通过命令：gcc -E ./a.c -o ./a.i得到预处理文件；
            
            3：对预处理文件进行编译操作，得到汇编文件：
                1：将预处理之后得到的预处理文件编译之后即可得到特定汇编代码组成的文件；
                2：编译完成之后得到的汇编文件是由特定汇编代码组成的，仍然是文本文件；
                3：汇编文件以.s作为后缀，在linux中使用gcc编译器可以通过命令：gcc -S ./a.c -o ./a.s得到汇编文件；
            
            4：对汇编文件进行汇编操作，得到当前C源程序文件的二进制目标文件：
                1：将编译完成后的汇编文件转换成二进制的目标文件的过程称为汇编；
                2：汇编完成之后得到的目标文件是由二进制代码组成的，是二进制文件；
                3：汇编文件以.o作为后缀，在linux中使用gcc编译器可以通过命令：gcc -c ./a.s -o ./a.o得到目标文件；
            
            5：对二进制目标文件链接操作，得到二进制的可执行文件；
                1：一个可执行文件包括四个部分：
                    1：启动代码
                    2：使用到的库函数代码
                    3：当前C源文件汇编得到的目标文件
                    4：组成C源程序的其他C源文件汇编得到的目标文件；
                    上一步汇编完成之后只是得到了一个C当前源文件的目标文件，还缺少启动代码、引用到的库函数代码以及组成C源程序的其他C源文件的目标文件，所以还不能作为可执行文件运行起来；
                2：链接的过程即为将当前C源文件汇编得到的目标文件，启动代码，库函数代码和组成C源程序的其他C源文件的目标文件合并成为一个完整的可执行文件的过程；
                3：可执行文件以.out作为后缀，在linux中使用gcc编译器可以通过命令：gcc -o ./aim.out ./a.o ./b.o得到可执行文件；
                4：链接完成之后即可得到最终的可执行文件，在linux平台上以.out作为后缀，在windows平台上，以.exe作为后缀！由于linux平台对于文件后缀并无要求，因此.out可以省略；
        
    四：C语言编译器：
        Linux上的常用的编译器为：gcc（最终可执行文件的后缀名为.out，windows上的可执行文件后缀为.exe）
    
C语法部分：
    1：C语言语法基本要求
    2：C语言基本语法内容
    3：C语言标准库
    4：C语言高级部分

    一：C语言语法基本要求：
        1：C源程序的组成：
            1：一个C源程序可以由一个或者多个C源文件组成； 
            2：一个C源程序的每一个C源文件都以.c作为后缀；
            3：每一个C源文件都是由若干个函数以及若干个声明语句(头文件的包含、宏的定义、类型的定义、常量的定义，全局变量的声明、函数的声明、预处理语句)组成；
        
        2：程序执行方式：
            1：C程序执行时，从主函数开始执行，并从主函数结尾，并将执行状态以整数的形式返回给执行环境；
            2：一个C源程序必须要有并且只能有一个主函数；这个主函数可以放在任意一个C源文件中；
            3：源程序必须先编译链接为可执行文件，再由操作系统执行该可执行文件来执行程序；

        3：C主函数：
            1：一个C源程序必须要有，并且只能有一个主函数；
            2：如果一个C源程序由多个C源文件组成，那么主函数可以放在任意一个C源文件中；
            3：C程序执行时，从主函数开始执行，并从主函数结尾处结束执行；并将执行状态以整数的形式传递给执行环境；
            4：主函数的名称只能是main，不能自定义为其他名称；
            5：主函数的定义方式：
                标准定义方式：
                    1：int main(void){/* ... */}
                    2：int main(int argc,char *argv[]){/* ... */}
                非标准定义方式：
                    3：int main(int argc,char *argv[],char *envp[]){/* ... */}
            6：主函数的形参说明：
                1：按照标准方式定义，可以选择以第一种方式声明，即不接受任何参数，直接声明为void；
                2：按照标准方式定义，也可以选择以第二种方式声明，接收两个参数；其中：
                    int argc表示以命令行执行该程序的可执行文件时传入参数的个数；
                        如果没有传递任何参数时，其值为1，因为可执行文件本身的名称也算是一个参数；
                        如果有传入参数时，其值为参数个数+1；
                    char *argv[]：一个字符串数组，每一项都指向使用命令行执行该程序时传入的字符串参数；
                        其中argv[0]表示可执行文件的名称；
                        其余传入的参数可以通过argv[1]~argv[argc-1]获取；
                3：按照非标准形式定义时，会在第二种定义的方式上多一个envp参数，表示执行该可执行文件时的环境信息，若干个字符串，每一个字符串都以键值对的形式表示环境信息；该参数表示的环境信息也可以在程序中通过getenv()标准函数获取；
            7：主函数的执行结果：
                C源程序从主函数开始执行，也从主函数结尾处结束执行；在主函数执行结束后，会将执行状态以整数的形式传递给操作系统；
                1：返回值是0或者EXIT_SUCCESS，表示程序执行一切顺利；成功结束执行！
                2：返回值是任何其他非0值，尤其是EXIT_FAILURE，则表示程序执行时出现问题；并未成功执行完该程序；
                3：mian函数并非必须调用return显式的返回一个整数值，如果程序运行到main()的右' } '处，将会自动向执行环境返回状态值0，如果执行发生异常则将会自动向执行环境返回非0状态值；
                4：main()函数的结束等效于在主线程中调用标准库函数exit(),exit()的参数将会作为main()的返回值；

        4：C代码语法要求：
            1：以;作为语句结束符号；
            2：以{}作为代码块符号；
            3：以//作为单行注释，以/* ... */作为多行注释；
            4：标识符命名规范：
                1：以数字，字母，下划线组成；
                2：不能以数字开头；
                3：不能和关键字冲突；
                4：严格区分大小写；
                5：避免使用_或者__开头；
                6：避免使用拼音和英语混合式命名！
            5：一个C源文件结构上由两部分组成：1：函数、2：函数外部的语句；函数外部的语句只能是以下几种：头文件包含语句，宏的定义，类型的定义，常量的定义，全局变量的声明，函数的声明语句，预处理语句；其余具备运算能力或者逻辑处理能力的语句都必须放在函数内部！

    二：C语言基本语法内容：
        1：C语言输入输出(标准输出)：
            1：输出单个字符：
                putchar();      #如 putchar('c');
            2：输出字符串：
                puts();     #如 puts("string");
            3：打印任意数据类型的数据：
                printf()
                3.1：基本使用格式：
                    printf("format string",data1,data2,data3...);
                3.2：format string的组成：
                    format string由自定义字符和格式化字符组成；自定义字符将会原样打印，格式化字符将会按照顺序对后面的data1、data2等进行格式化，并替换为格式化之后的数据；
                3.3：格式化字符：%[flag][width][.precision][type]
                    flag：
                        -：默认输出是右对齐，带上-之后则为左对齐；
                        +：正数带上+号，负数带上-号；
                        #：对于小数，强制输出小数点，对于八进制，十六进制，二进制，带上前缀；
                        空格：用于数字：正数加空格，负数加负号；
                    width：
                        最小宽度限制；对于字符串，如果字符串字符个数不足将会使用空格补齐，如果字符个数超过最小宽度限制之后，该限制将会自动失效
                    .precision：
                        对于int类型，表示最小输出宽度，不足时将会使用0补齐；
                        对于float、double类型，表示输出精度(小数部位的位数)；
                        对于str类型，表示最大输出宽度；如果字符串长度超过该限制将会截取字符串；
                    type：
                        表述被格式化的数据需要被格式化为何种数据类型：
                        字符/字符串：
                            %c          //格式化成字符类型
                            %s          //格式化成字符串类型
                        浮点数：
                            %f          //格式化成单精度(float)类型的小数形式
                            %lf         //格式化成双精度(double)类型的小数形式
                            %e          //格式化成单精度(float)类型的指数形式
                            %le         //格式化成双精度(double)类型的指数形式
                            %E          //格式化成单精度(float)类型的指数形式(以大E表示)
                            %lE         //格式化成双精度(double)类型的指数形式(以小e表示)
                        十进制整数：
                            %d          //格式化成十进制、有符号、int类型整数
                            %hd         //格式化成十进制、有符号、short类型整数 
                            %ld         //格式化成十进制、有符号、long类型整数
                            %u          //格式化成十进制、无符号、int类型整数
                            %hu         //格式化成十进制、无符号、short类型整数 
                            %lu         //格式化成十进制、无符号、long类型整数
                        八进制整数：
                            %o          //格式化成八进制、无符号、int类型整数
                            %lo         //格式化成八进制、无符号、long类型整数
                            %ho         //格式化成八进制、无符号、short类型整数
                        十六进制整数：
                            %x          //格式化成十六进制、无符号、int类型整数
                            %lx         //格式化成十六进制、无符号、long类型整数
                            %hx         //格式化成十六进制、无符号、short类型整数
            4：打印单个宽字符：                
                putwchar()：只能输出单个宽字符，且要使用setlocale(LC_ALL,"zh_CN");来设置本地化
            5：打印宽字符串：
                wprintf()：用于输出宽字符串
                           宽字符标识：%ls;
                           用法：和printf完全一样

        2：C语言变量：
            1：C语言中变量使用基本要求：
                1：C语言中变量使用之前必须先声明，后使用；
                2：声明变量时，必须指明变量的数据类型，变量名称，如有必要可以赋上初始值；
                3：变量声明时，即确定该变量的数据类型；在程序运行过程中，变量只能指向和其数据类型相同的数据，不能指向其他数据类型的数据；

            2：C语言中变量命名规范：
                1：C语言变量名必须遵守C语言标识符命名规范；
                2：C语言变量推荐采用小写+ '_' 分割式命名；如：var_name
            
            3：C语言中使用变量：
                C语言中的变量由两种类型：全局变量和局部变量；
                1：全局变量：在函数外部声明的变量称之为全局变量；
                    1：声明位置：在函数外部声明；
                    2：初始值：
                            1：如果在声明全局变量的同时赋予该变量初始值，那么该变量的初始值即为设置的值；
                            2：如果声明的同时未赋值：
                                那么对于int类型的变量其初始值为0；
                                指针类型的初始值为null；
                                浮点数类型的初始值为：0.000000；
                                字符串类型的初始值为"";
                    3：注意事项：
                        在函数外部只能进行全局变量的声明，不允许进行变量的运算，赋值，打印等其他操作；
                    4：全局变量的类型：
                        全局变量按照声明方式的不同，分为普通全局变量和静态全局变量：
                    5：普通全局变量：
                        1：声明方式：数据类型 变量名 = 初始值;
                        2：作用域：普通全局变量的作用域为组成该C源程序的所有源文件，即不允许在不同的源文件中出现同名的普通全局变量；
                        3：特性：普通全局变量可以在其他源文件中使用 extern引入；引用方式：extern 数据类型名 普通全局变量名
                    
                    6：静态全局变量：
                        1：声明方式：static 数据类型 变量名 = 初始值;
                        2：作用域：静态全局变量的作用域仅在当前源文件中；即允许在不同的源文件中出现同名静态全局变量；
                        3：特性：静态全局变量的作用域仅在当前源文件中，因此不允许在其他源文件中引入其他文件中的静态全局变量；
                
                2：局部变量：在函数内部声明的变量称之为局部变量：
                    1：声明位置：
                        对于c89/c90规定，在任何执行语句之前，在块的开头声明所有局部变量；
                        对于c99和c++中则没有这个限制，局部变量声明可以放在首次调用之前的任意位置；
                    2：初始值：
                        对于局部变量，其声明时如果没有给定初始值，那么其初始值是不确定的，无论是何种数据类型的局部变量，只要未给定初始值，其初始值就是不确定的；
                    3：局部变量的类型：
                        局部变量根据声明的方式分为自动局部变量和静态局部变量；
                    4：自动局部变量：
                        1：声明方式：数据类型 变量名 = 初始值;   或者  auto 数据类型 变量名 = 初始值;
                        2：作用域：仅限当前函数中，声明语句之后使用；
                        3：生命周期：自动局部变量的生命周期和其所在的函数一致，函数被调用时对该局部变量进行初始化，函数调用完成之后该局部变量即被销毁，下次调用该函数时重复上述流程；
                        4：自动局部变量如果不赋初值，其值是无意义的不确定的；
                    5：静态局部变量：
                        1：声明方式：static 数据类型 变量名 = 初始值; 
                        2：作用域：仅限当前函数中，声明语句之后使用；
                        3：生命周期：静态局部变量的生命周期和应用程序一致，函数首次被调用时对该静态局部变量进行初始化，函数调用完成之后该静态局部变量并不会被销毁，下次调用该函数时该函数将不再重新声明和初始化，其值为上次函数调用完毕之后最后一次对该变量的修改；
                        4：静态局部变量如果不赋初值，其值是无意义的不确定的；

        3：C语言常量：
            常量即为值不能修改的量，C语言中通过const关键字创建一个常量或者将变量修饰为常量；
            1：常量使用方式：
                1：通过const关键字创建一个常量：const 数据类型 常量名 = 值；
                2：通过const关键字将变量修饰为一个常量：const 变量名；
                3：通过const关键字将函数参数修饰为一个常量：const 数据类型 形参名称；
            
            2：常量使用时的注意事项：
                1：通过const创建常量时，必须在创建的同时对常量进行初始化，否则将无法再对常量赋值；
                2：通过const修饰变量为常量时，在修饰完成之后，该变量将不能在重新赋值；
                3：对于函数形参，如果为了防止函数内部对形参做了修改，可以将形参修饰为常量；
            
            3：const在修饰不同数据类型时有不同的结果：
                1：对于基本类型数据(int float)：使用const修饰之后，该变量本身将不能再重新赋值；
                2：对于指针类型数据：使用const修饰时有以下三种情况：
                    const char * uname;   
                    此时const修饰的是指针所指向的内存空间，因此uname指向的内存地址中存储的数据不允许再被修改，但是指针本身可以指向其他内存地址；

                    char * const uname;
                    此时const修饰的是指针变量本身，因此uname指向的内存地址中不允许再被修改，即该指针不能再指向其他内存地址，但是指针指向的内存空间中存储的数据被修改；

                    const char * const uname;
                    此时const既修饰指针变量本身也修饰指针变量所指向的内存空间，因此uname指向的内存地址中不允许再被修改，即该指针不能再指向其他内存地址，并且指针指向的内存空间中存储的数据也不允许再被修改；
            4：关于常量的赋值：
                1：C语言不允许将const类型的变量赋值给一个非const类型的变量，但是允许将非const类型的变量赋值给const类型的变量；
                2：尤其对于指针变量而言，const char * uname 此种类型表示指针指向的内存空间中的内容不允许被修改，如果将uname的值赋值给非const类型的指针变量,该内存中的值就可以通过新的指针变量来修改；失去了常量的意义；因此这种行为在C语言中不被允许；

        4：C语言运算：
            1：符号类型运算：
                1：()：
                     表示优先执行()中的语句；
                2：*：
                    用在非声明场景下表示取值符，表示获取一个指针变量所指向的内存空间中的数据；
                    用在声明场景下表示紧跟 * 后面的变量为指针变量；
                3：&：
                    用在单运算时表示取地址符，表示获取一个变量的内存地址；
                    用在双运算时表示按位与运算；
                4：[]：
                    表示在紧跟在[]之前的变量表示的是一个数组；
                
            2：符号类型运算级别：
                ()运算优先级最高，任何情况下都先执行()中的语句；
                []作为后缀运算符，其优先级仅此于();
                *和&(表示取地址符时)作为前缀运算符，其优先则低于后缀运算符[]；
            
            3：数值类型运算：
                1：算术运算：+ - * / % ++ --
                    使用范围：只能适用于数字
                    运算方向：从左至右运算
                    级别：仅次于逻辑运算中的' ! '，大于关系运算
                    备注： 
                        对于除法：
                            如果除数和被除数都是整数，那么得到的结果也是整数；
                            如果除数和被除数有一个是小数，那么得到的结果也是小数；并且是double类型的小数；
                        对于取余运算：
                            C语言中的取余运算只能针对于整数进行，即%两边都必须是整数，否则编译器将会报错！
                        对于自增自减运算：自增/自减运算在和赋值运算一起进行的时候需要注意前后位置关系：
                            前自增在赋值时先运算后赋值；
                            后自增在赋值时先赋值后运算；
                
                2：比较运算：< > <= >= == !=
                    运算方向：从左至右
                    级别：整体级别大于逻辑运算符的&&和||，小于算术运算符，但是同级别内< > <= >=的级别高于==和!=；
                
                3：逻辑运算：&& || ！
                    运算方向：从左至右
                    级别：&& 和 || 小于关系运算符，！小于()大于算术运算符
                    运算结果：运算结果是一个Bool值

                4：赋值运算：= += -= *= /= %= 
                    方向：将右侧的值赋给左侧
                    级别：级别最低；
                
                5：6种位运算：& | ^ ~ << >>
                    &：
                        按照二进制位求与运算，两个二进制位都为1才为1，只要有一个为0即为0；
                    |：
                        按照二进制位求或运算，两个二进制位一个为1即为1，两个都为0时才为0；
                    ^：
                        按照二进制位求异或运算，如果两个二进制位的值不同即为1，否则即为0；
                    ~：
                        按照二进制位取反：获取某个数值的补码；
                    <<:
                        按照二进制位全部左移，高位丢弃，低位补0；如x<<y：x数值向左移动y位；左移 y 位相当于乘以 2 的 y 次方;
                    >>：
                        按照二进制位全部右移，如果左侧操作数是无符号类型或者是有符号类型，但是为非负值，则右移时左侧多出了的位直接补0，该情况下右移y位等效于除以2的y次方；如果左侧是负值，则由编译器确定左侧是补充0还是符号位，如果是补充符号位依然等效于除以2的y次方，但是如果是补0，则不等效；
                    注意：
                        1：参与位运算的必须是整数；
                        2：参与移动位运算的两侧数值必须都是整数；右侧的数值不能为负值，并且不能超过左侧数据的位长；
            4：数值类运算级别：
               符号类型运算 > ! > 算术运算 > 关系运算 > &&和|| 
               移位运算符的优先级高于比较运算符和其他位运算符，但是低于算数运算符；

        5：C语言流程控制：
            1：条件控制：
                1：if..else条件语句：
                    if(表达式)
                    {

                    }
                    --------------------------
                    if(表达式)
                    {

                    }else if(表达式)
                    {

                    }else{

                    }
                    --------------------------
                    if(表达式)
                    {

                    }else{

                    }
                2:switch条件语句：
                    switch(var){
                        case 1:
                            code..
                            break;
                        case 2:
                            code..
                            break;
                        default:
                            code...
                    }
                    备注： 
                        1：switch中只能是整数，不能是浮点数或者其他数据类型；
                        2：case只能是整数，不能是浮点数或者其余数据类型；
                        3：多个分支有共同处理方式，则多个分支可以放在一起，只在最后一个分支结束时使用break语句；
                        4：default不是必须的；当所有的case都无法匹配时，将会走进default;
                        
                3：? :   三目运算符；int a= b>0 ? b : 0

            2：循环控制：
                for(int i=0;i<n;i++)
                {

                }
                --------------------------
                while(表达式)
                {

                }
                --------------------------
                do
                {

                }while(表达式);(;一定要有)

            3：跳出循环：
                1：break;结束当前循环；
                2：continue;结束当前循环，并开始新的循环！
        6：C语言基本数据类型：
            1：基本数据类型：整数、浮点数、字符
            2：整数：无小数部分的数字，包括负整数、0、正整数；
                1：整数类型：
                    short int
                        可简写为：short                     
                        占用空间：2字节(16位)   -32768到32767      
                        有符号类型                
                    unsigned short int                   
                        可简写为：unsigned short
                        占用空间：2字节(16位)  0~65535
                        无符号类型

                    int                           
                        占用空间：2/4字节(16位/32位)   -32768到32767或者-2e32到2e32-1       
                        有符号类型
                    unsigned int  
                        可简写为：unsigned                
                        占用空间：2/4字节(16位/32位)   0~65535或者0~2e33-1
                        无符号类型        
                    特别注意：int类型具体占用几个字节和平台以及编译器有关

                    long int                             
                        可简写为：long
                        占用空间：8字节(64位)  -2e64到2e64-1
                        有符号类型
                    unsigned long int                     
                        可简写为：unsigned long
                        占用空间：8字节(64位)  0~2e65-1
                        无符号类型

                    在C99标准中又新增了long long int类型：
                    long long int                        
                        可简写为：long long
                        占用空间：8字节(64位)    -2e64到2e64-1
                        有符号类型
                    unsigned long long int             
                        可简写为：unsigned long long
                        占用空间：8字节  0~2e65-1 
                        无符号类型
                2：无符号类型和有符号类型：
                    有符号类型：
                        signed修饰下为有符号类型，signed是默认类型，无需显式声明；
                        有符号类型包括：负整数、0、正整数；
                        取值范围在负数最小值和正数最大值之间；
                    无符号类型：
                        unsigned修饰下为无符号类型，unsigned不是默认类型，必须显式声明；
                        无符号类型包括：0、正整数；
                        取值范围在0和正数最大值之间；
                3：数据溢出：
                    向上溢出
                        数据向上溢出时，将会从数据类型的最小值开始从新计数，不同的是：
                            有符号类型溢出之后，将直接从负值最小值开始从新计数(向上递增)；
                            无符号类型溢出之后，将直接从0开始从新计数(向上递增)；
                    向下溢出：
                        无论有符号还是无符号，均是从正值最大值从新计数(向下递减)；不同的是有符号类型和无符号类型的正值最大值不同！
                4：对于正数类型占用字节个数的说明：
                    所有的整数类型表示的数值范围都和具体的平台以及编译器实现有关，C语言规范并未明确要求某种类型占据多少字节；上述范围表示linux平台GCC编译器下的数值范围；    
            
            3：浮点数：带有小数部分的数字
                1：浮点数类型：
                    float       占用4个字节    单精度    有效位数6位  
                    double      占用8个字节    双精度    有效位数15位
                    long double 占用16个字节   双精度    有效位数19位

                2：浮点数精确度描述：
                    1：浮点数在内存中存储时，正数部分和小数部分是分开转换成二进制存储的；十进制转二进制时采用的是除2取余逆序排列法；有些情况下，小数部分无法被2整除，将会造成无线小数，但是能够存储小数位数的空间有限，将会在精度位的后一位进行四舍五入，最终导致实际保存的小数和真实的小数存在差异；
                    2：精度越高，存储的小数部分数字越接近真实小数，但是仍然和真实小数有区别；
                    3：由于浮点数存在精度问题，因此禁止在程序中使用==来检测两个小数是否相等；
                
                3：浮点数的表达形式：
                    1：浮点数可以使用小数的形式表达，如：1.222
                    2：也可以使用指数的形式表达，如：1222e-3或者1222E-3

            4：字符：
                1：字符类型：
                    1：C语言中使用char来表示一个字符类型，使用''来表示一个字符；
                    2：char类型的大小为1个字节，表示范围在-128~127之间；unsigned char的表示范围在0~255之间；
                2：宽窄字符：
                    1：在C89/C90中C语言使用ASCII字符集和字符编码作为语言的字符集和字符编码；字符在保存时实际保存的是字符在字符集中的编号；
                    2：对于中文字符，在windows平台采用utf-16存储，使用2个字节存储一个中文字符；但是在unix平台采用utf-32存储，即使用4个字节存储一个中文字符；为此，C语言推出wchar_t类型来表示中文字符，wchar_t的类型的长度由编译器决定！wchar_t类型位于<wchar.h>头文件中！
                    3：使用wchar_t类型的字符称之为宽字符；由宽字符表示的字符串称之为宽字符串；使用wchar_t这种宽字符需要在字符前加L；如：wchar_t d = L'国';
                    4：宽字符的打印：
                        putwchar():只能输出宽单个字符，且要使用setlocale(LC_ALL,"zh_CN");来设置本地化
                        wprintf():  用于输出宽字符串
                                    宽字符标识：%ls;
                                    用法：和printf完全一样
                3：转义字符：
                    1：转义字符以\或者\x开头，以\开头表示后跟八进制形式的编码值，以\x开头表示后跟十六进制编码值，对于转义字符来说，只能使用八进制或者十六进制；
                    2：转义字符的初衷是用于ASCII编码表示一些非打印字符，因此取值范围有限：
                        八进制形式的转义字符最多后跟三个数字，即\ddd,最大取值\177;
                        十六进制形式的转义字符最多后跟两个数字，即\xdd，最大取值\x7f
                        超出范围的转义字符是未定义的，如果是用超出范围的转义字符，编译器要么报错，要么直接输出！
                    3：对于ASCII编码，0~31范围内的字符为控制字符，只能用转义字符来表示，常见的转义字符如下：
                        \a 	响铃(BEL)     
                        \b 	退格(BS)  
                        \f 	换页(FF)  
                        \n 	换行(LF)  
                        \r 	回车(CR)
                        \t 	水平制表(HT)     一般相当于四个空格，或者 tab 键的功能    
                        \v 	垂直制表(VT)    
                        \' 	单引号 
                        \" 	双引号 
                        \\ 	反斜杠
        7：NULL：空指针
            1：NULL的本质：NULL本质上是一个宏，该宏的值是一个指针；
            2：NULL的原型：#define NULL ((void *)0)，即NULL是一个指针，指向地址为0的存储单元；
            3：关于NULL的指向：C语言规范中并未规定NULL的指向，只是大多数编译器默认将NULL指向地址为0的存储单元；
        
        8：void类型：
            1：void类型：void类型表示没有可用的值；
            2：void类型使用场景：
                1：函数返回值：如果函数没有返回值需要使用void表示；
                2：函数的参数：如果函数不接受任何参数，可以使用void来表示；
                3：指针指向void：指向void的指针可以指向任何数据类型；

        9：C语言基本数据类型转换：
            1：自动类型转换：自动类型转换是由编译器根据计算需求，自动将数据类型进行转换的一种方式；
                自动类型转换发生在两种情况下：
                    1：赋值时：
                        如果类型转换合法，将会把右侧的变量转换为左侧变量的数据类型，然后赋值给左侧变量，右侧的数据类型不会被改变！但是将高精度值赋给低精度值时将会发生精度损失
                    2：运算中：
                        在运算时，编译器会将所有的数据的类型转换为同一种数据类型，然后再进行计算！
                        1：转换方向：
                            char/short->int->long
                                             ->float->double
                              转换方向为数据长度增加方向(高精度方向)进行;
                        2：所有的浮点运算都是以双精度进行的，即使运算中只有float类型，也将全部转换为double进行运算；
                        3：需要注意的是存储运算结果时由于运算结果类型的变化导致数值的溢出！

            2：手动类型转换：
                强制类型转换方式：(目标数据类型)待转换变量  
            
            3：类型转换的注意事项：
                1：无论是强制还是自动类型转换，转换改变的仅仅是结果，源数据的类型并不会改变！
                2：无论是强制还是自动类型转换，高精度往低精度转换都会发生精度损失！
                3：无论是强制还是自动类型转换，数据类型转换要合适，只能在基本数据类型之间转换，否则编译器将会报错！
                4：无论是强制还是自动类型转换，都要注意类型转换之后溢出的问题，尤其在自动类型转换中；
        10：C语言复杂数据类型：
            指针：
                1：存储单元和内存地址：
                    1：CPU处理数据时，数据必需先加载至内存中，才能够被CPU访问；
                    2：而内存的物理实体就是内存条，内存在操作系统中会被分割为若干个1字节大小的存储单元，每一个存储单元都会有一个编号，这个编号称之为存储单元的地址或者内存地址；通过这个地址即可向存储单元中存储数据，或者从该存储单元中获取数据；
                    3：由于一个存储单元只有1个字节大小，因此在声明变量时，系统将会按照变量的数据类型在当前系统所占用的字节个数，来分配若干个连续的存储单元作为一个内存块给该变量使用；
                    4：存储单元的地址从0开始编号，并以16进制表示；数据类型为unsigned int;
                2：对于指针的理解：
                    从概念上来看：指针类似一个箭头，指向某个存储单元，这个箭头是虚拟的，并不真实存在；
                    从编程上来看：指针表示的就是某个存储单元，在程序中的具体体现就是指针变量，指针变量的值即为某个存储单元的地址；通过指针变量的值即可确定某个存储单元的地址，进而通过该地址访问存储单元中的内容；
                3：指针和数据的理解：
                    1：数据是指存储在存储单元中的内容；可以为任何数据类型；
                    2：指针表示的是某个存储单元，在程序中的具体表现形式是指针变量，指针变量的值是某个存储单元的地址，通过指针即可访问某个存储单元中的内容；指针变量的值即存储单元的地址数据类型固定为unsigned int类型；
                4：指针变量和普通变量的区别：
                    1：意义不同：
                        1：指针变量是指针在程序中的具体体现，其值表示的是存储单元的地址，类型固定为unsigned int；以十六进制表示；
                        2：普通变量代表的是具体的数据，其值是存储单元中的内容；类型在声明变量时确定；
                    2：数据类型不同：
                        1：指针变量的数据类型固定位unsigned int 类型；
                        2：普通变量的数据类型则在声明时确定；
                    3：运算方式不同：
                        1：指针变量在运算时本质上是改变指针对存储单元的指向；
                        2：普通变量在运算时本质是存储单元中内容的修改；
                    注意：
                        1：本质上指针变量和普通变量并没有任何区别，都代表的是数据，只是指针变量代表的数据表示的是某个存储单元的地址，而普通变量表示的数据是某个存储单元的内容；
                        2：虽然指针变量的数据类型为unsigned int，但是不允许将指针变量和数据类型为unsigned int的普通变量进行运算；因为两个变量表示的意义不同，系统在处理时的方式也不同；
                        3：指针变量的值本身也是需要存储在存储单元组成的内存快中，因此存储指针变量值的存储单元同样也是可以被其他指针指向的；
                5：指针变量的声明：
                    1：声明方式：
                        数据类型 * 变量名 = 初始值; 
                            或者  
                        数据类型 *变量名 = 初始值;
                    2：指针变量声明说明：
                        1：数据类型：表示的是指针指向的存储单元组成的内存块中要存储的数据的数据类型；系统将会按照数据类型分配若干个连续的存储单元；一旦声明完成之后，该指针指向的若干个存储单元将只能存储指定数据类型的数据；
                        2：*可以和变量间隔一个空格也可以紧挨着变量，在声明场景下，*表示紧跟其后的变量是一个指针变量；
                        3：指针变量的命名和普通变量的命名规范一致；
                6：指针的运算：
                    1：&：该运算是取地址符；该运算符可以使用在普通变量和指针变量之前，用来获取变量的内容在内存中的地址，即变量的内容所占用的内存块首个存储单元的地址；
                    2：*：该运算符是取值符，可以通过*获取指针指向的存储单元中所存储的值；
                    3：通过指针变量向内存中设置值：*指针变量 = 值；
                    4：指针变量允许和同类型的指针变量之间互相赋值：赋值完成之后，两个指针变量指向同一个存储单元；(参与赋值的两个指针变量必须数据类型相同)；
                    5：指针变量可以参与算数运算：指针变量允许加上或者减去一个整数或者对指针变量进行自增自减运算，来改变指针对存储单元的指向；
                    6：对于指针变量加减整数或者自增自减运算说明：
                        1：普通变量加减某一个整数是指给存储单元中存储的数据本身加/减去n，不会引起数据在内存中存储地址的改变；
                        2：指针变量加减某个整数m或者自增自减运算:
                            微观上看：指针变量加/减某个整数m，是指将指针变量的指向跳过n*m个存储单元，n是指当前指针变量数据类型在当前平台所占字节个数；
                            宏观上看：指针变量的加减运算改变的是当前指针对存储单元的指向；
                        3：不允许对指针变量做除过加减一个整数/自增自减以外的任何其他算术运算；
                        4：普通的指针变量做自增自减或者加减运算并无任何实际意义；指针的指向会改变，但是指向新的存储单元中的数据则是不确定的；
                        5：对于数组或者字符串,由于其占用的是一段连续的存储单元，因此指针变量的加减/自增自减改变的是指针指向的元素位置，其值是可以预料的，通过对指针位置的改变可以获取到相邻的元素值，是有意义的；
                7：空指针：
                    1：在函数中声明一个指针变量但是并不初始化，那么该指针变量的值是不确定的，因此该指针的指向也是不确定的，一般情况下都是指向一个无读写权限的地址，将会造成程序的隐患；
                    2：建议在函数中声明指针变量时对其初始化，如果不知道指针变量的初始值，可以将指针变量的值设置为NULL；即把该指针设置为一个空指针；C语言并未规定空指针的指向，但是大多数编译器将空指针指向地址为0的存储单元，并且其类型未知；
                    3：对于指针而言，在除过赋值类型的操作以外，要先检测，后操作；严禁对空指针进行赋值以外的操作；

                8：二级指针：
                    1：如果指针指向的内存存储的是普通数据，那么该指针称为一级指针，指向存储一级指针变量值的内存的指针称之为二级指针，以此类推三级指针等；
                    2：二级指针以上，无论是几级指针，都是普通的指针，都是指向一个存储单元，仅仅只是其指向的内存中存储的内容是另一个指针变量的值而已；
                    3：无论是几级指针变量，都表示一个普通的变量，其值都是一个unsigned int 类型的数据，其值都表示一个存储单元的地址；
                    4：一级指针变量需要使用*来声明，需要使用*来取值；二级指针变量需要使用**来声明，需要使用**来取值；三级四级依次类推；对于二级指针使用*来取值得到的是以及指针的地址，需要对该地址再次取值运算才能得到最终的值。多级指针原理相同；


            数组：
                1：数组的基本概念：
                    1：数据的有序集合称之为数组
                    2：数组中的每一个值称为数组的元素
                    3：数组中元素的个数称之为数组的长度
                    4：数组中元素按照顺序排列，每一个序号可以唯一确定一个数组元素，因此可以通过元素的序号访问数组元素；
                
                2：数组的声明方式：  
                    1：数组是一个数据容器，在使用之前需要先声明才能使用；
                    2：数组的声明方式：数据类型 数组名[数组长度];
                    对数组声明的几点说明：
                        1：数组声明时就要确定数组的长度，声明时确定的长度即为数组最多容纳的元素数量；一旦声明完成，该长度不允许再被改变，存储数组元素也不允许超过做大限制，否则将会溢出；
                        2：数组声明时即确定数组元素的类型，一旦声明完成，数组中只能存储指定数据类型的数据；不允许存储其他类型的数据；
                        3：对于数组而言，在函数内部声明数组时，如果声明完成后未初始化，那么数组中的元素则是不确定的；
                        4：[]符号为数组符号，表示其之前的紧跟的变量为数组；属于后缀符号，在符号优先级中仅次于()，高于取地址运算符&和取值运算符*;
                        5：数组名称需要符合C语言标识符命名规范；
                
                3：数组的赋值：
                    1：数组可以在声明的同时完成赋值：
                        1：完全赋值：给所有数组元素都赋上初值；
                                    如：int arr[3] = {1,2,3}
                                备注：
                                    1：完全赋值时数组可以不用显式指定长度；
                                        如：int arr[] = {1,2,3}

                        2：不完全赋值：赋值的个数少于数组声明时指定的个数；
                                    如：int arr[3] = {1}
                                备注：
                                    1：不完全赋值时，必须明确表示数组的长度；
                                    2：不完全赋值时，数组未赋值的部分也会按照基本规则进行初始化：
                                        1：如果数组类型为：int,short,long,将直接赋值为整数0；
                                        2：如果数组类型为：char,将赋值为\0；
                                        3：如果数组类型为：float或者double，则将会赋值为0.0；
                    2：数组也可以在声明完成之后进行赋值：
                        数组在声明完成之后只能通过下标一个一个对单个数组元素进行赋值，不能再使用{}整体进行赋值;

                4：对于数组的理解：
                    1：数组是占用一段连续的存储单元来存储数组元素的，这段连续的存储单元的长度为当前数组元素的数据类型在当前平台占据的字节个数m*数组声明时的长度n；
                    2：数组元素在赋值的时候只能赋值数组声明的数据类型的值，不能赋值其他数据类型的值；
                    3：C语言中数组是静态数组，即长度一旦声明好之后将不能再改变，插入数据的个数不能超过长度，否则将会出现溢出；
                    4：固定长度的数组是在编译期间分配内存的；
                
                5：二维数组：
                    1：二维数组的理解：
                        在形态上：二维数组类似于一个矩阵，一维长度指该矩阵的行数，二维长度指该矩阵的列数；
                        在存储上：二维数组仍然是按照一维线性存储，每一行紧挨着上一行存储；
                        在元素上：二维数组类似于一个包含了若干个一维数组的一维数组；
                    2：二维数组的声明：
                        数据类型 数组名[一维长度][二维长度];
                    3：二维数组形态上的理解：
                        1：二维数组在组成结构上类似与一个矩阵，一维长度指该矩阵的行数，二维长度指该矩阵的列数；
                        2：数组元素可以通过一维行数和二维列数唯一确定；
                    4：二维数组存储上的理解：
                        1：虽然二维数组在形态上类似于一个矩阵，但是在实际存储时，仍然是一维线性存储的，即一行挨着一行存储；
                    5：二维数组在元素上的理解：
                        1：二维数组可以看做一个矩阵，那么每一行数据都可以看做一个一维数组，此时一个二维数组可以看做是一个由若干个一维数组作为元素组的一维数组；
                    6：二维数组的赋值：
                        1：分段赋值：按照二维数组的行数赋值
                            1：完全赋值：每一行都完全赋值,虽然是完全赋值，但是一维的长度一定要给出；   
                                        int a=[3][2] = {{1,2},{3,4},{5,6}}
                            2：部分赋值：每一行都只赋值一部分，默认从左向右赋值，其余未赋值的部分则按照数据类型自动填充；
                                        int a[2][4] = {{1,2},{3}}   会自动填充为:{{1,2,0,0},{3,0,0,0}}

                        2：连续赋值：按照一维的方式赋值，并且系统会按照二维的长度自动分行
                            1：完全赋值：从左向右按行赋值；此时可不必给出一维长度，系统会按照二维的长度自动分行；
                                int a[][2] = {1,2,3,4,5,6}   会自动分行为:{{1,2},{3,4},{5,6}}
                            2：部分赋值：从左向右按行赋值；其余则按照数据类型填充；
                                int a[3][2] = {1,2,3}   会自动分行为:{{1,2},{3,0},{0,0}}
                        
                        3：二维数组在声明完成之后赋值，只能按照数组元素一个一个赋值；不允许再整体赋值；
                    7：二维数组的数组名：
                        1：二维数组的首地址：
                            由于二维数组可以看做由若干个一维数组组成的一个大的一维数组；所以二维数组的首地址本质上是第一行元素组成的一维数组的首地址的地址；
                        2：二维数组的数组名：
                            和一维数组的数组名相同，在sizeof()和&取地址运算符以及定义数组时表示的是整个二维数组，除此之外表示的是二维数组的首地址；
                        3：二维数组名表示二维数组首地址时的本质：
                            二维数组的数组名表示二维数组首地址时本质上是一个二级指针，指向第一行元素组成的数组的首地址；即：*二维数组名 即可得到第一行元素组成的数组的首地址(注意是第一行元素组成的数组的首地址，不是第一行元素组成的数组的第一个元素)；
                        4：二维数组指针：
                            是指指向二维数组中某一行的指针，本质上仍然是个二级指针；指向二维数组中的某一行的首地址；
                        5：二维数组指针的声明：
                            数据类型 (*指针变量名)[第二维长度] = 二维数组名; 即可
                        再说明：
                            二维数组指针指向的是二维数组中某一行的首地址，并非二维数组中的某一行；
                            二维数组名表示二维数组首地址的时候，同样指的是二维数组第一行的首地址，而非二维数组的第一行；
                6：数组与指针：
                    1：数组占用的是一段连续的存储单元，占用存储单元的个数为当前数组中元素的数据类型在当前平台占用的字节个数*数组的长度；每一个元素占用的存储单元个数为当前元素在当前平台占用的字节个数；数组中的元素按顺序排列，每一个元素都有确定的序号和存储位置；
                    2：数组名：
                        1：数组名仍然是一个变量，既可以代表整个数组，也可以代表数组中首个元素的内存地址，即数组的首地址；
                        2：C语言中在&运算符、sizeof运算符、数组声明时数组名代表整个数组，除上述三种情况以外，数组名均代表数组的首地址；当数组名表示数组首地址时，数组名本质上是一个指针变量；
                    3：数组指针：
                        1：指向数组某个元素的指针称之为数组指针；数组指针和普通指针并无任何区别，仅仅只是数组指针指向的内存中存储的是某个数组中的某个元素而已；
                        2：数组指针指向数组中的某个元素，仅仅只能代表其指向的元素，即使其指向的是数组的首个元素，也不能代表整个数组；
                        3：由于数组占用的是一段连续的存储单元，每一个元素的位置已经唯一确定，因此对数组指针向前向后移动也能够明确移动之后的指针指向哪一个元素，因此除过通过数组序号以外也可以通过数组指针的增减来访问数组元素；

                7：数组的基本操作：
                    1：获取数组长度：
                        int len = sizeof(数组名)/sizeof(数组元素类型)
                        注意：
                            1：此种方式计算数组长度时，数组名必须代表的是整个数组，不能是指向第一个元素的数组指针；
                            2：如果函数要求传入数组类型的数据，此时如果传入数组名则仅仅代表的是数组的首地址，并不能代表整个数组，根据传入的数组名也无法使用sizeof来计算数组的长度，数组长度需要单独传入；
                    2：数组的取值：
                        1：通过数组名访问：数组名[下标]
                        2：通过指针的方式访问：*(数组名+下标)
                        3：通过数组指针访问：*(数组指针+n)

                    3：数组的赋值：
                        1：通过数组名赋值：数组名[下标] = 值
                        2：通过指针的方式赋值：*(数组名+下标) = 值
                        3：通过数组指针赋值：*(数组指针+n) = 值 

                8：指针数组：
                    1：指针数组是指数组的每一项都代表一个指针；本质上和普通的数组并无区别！

                    2：指针数组的声明方式：
                        1：数据类型名 *数组名[数组长度]
                        2：数据类型名 *(数组名[数组长度])
                        3：注意安装符号运算优先级，后缀运算符的优先级高于前缀运算符，因此*后面的括号可以不用带；

                    3：数组指针和指针数组的区别：数组指针指的是指向数组中某一个元素的指针；指针数组是一个数组，只是数组的每一项都是一个指针！

                    4：对于指针数组声明方式的理解：
                        指针数组的声明方式为：数据类型名 *数组名[数组长度]；
                        1：根据C语言中的运算优先级规则来看，[]后缀运算符的优先级大于前缀运算符*，所以，先根据数组名之后的[]确定该变量是一个数组，在根据数组名之前的*以及数据类型来确定数组中的元素是指定数据类型的指针；
                        2：由于后缀运算符[]的优先级大于前缀运算符*；因此()可以有也可以没有；

                    5：指针数组名的理解：和普通数组一样，在声明、&、sizeof()运算符中代表的是整个数组，即代表数组中的每一个元素；除此之外，指针数组名代表指向第一个数组元素的地址，由于第一个元素也是指针，所以指针数组名此时代表的则是二级指针；   


            字符串： 
                1：C语言中的字符串：
                    1：C语言中使用""来表示一个字符串，但是并没有字符串类型来表示一个字符串；在C语言中通过字符数组来保存字符串中的每一个字符；
                2：字符串的创建和初始化：
                    1：通过字符数组的方式创建：字符串在C语言中本就是以字符数组的方式存储，所以可以通过字符数组的方式创建字符串：
                        1：创建方式：
                            char str[n]      #创建一个具有n个字符的字符串；
                        2：赋值：
                            1：按照数组的方式赋值，可以完全赋值，也可部分赋值：
                                char str[3] = {'s','t','r'}或char str[] = {'s','t','r'}
                            2：按照字符串的方式赋值，可以直接赋值为字符串常量：
                                char str[3] = {"str"}或char str[] = {"str"}或char str[] = "str"
                            3：字符串以数组的方式声明，一旦声明完成之后赋值，将只能按照字符一个一个赋值，不允许再整体赋值；
                        3：字符串的存储位置：
                           以字符数组的方式声明的字符串，无论以何种方式初始化，都是在全局区域保存，具备读写权限，即可以对创建的字符串本身修改；

                    2：通过字符指针的方式创建：
                        1：创建方式：char *str
                        2：赋值：
                            1：按照数组的方式初始化：char *str = {"string"}
                            2：按照字符串的方式初始化：char *str = "string"
                        3：字符串的存储位置：
                            以指针的方式声明的字符串，只能以""的方式初始化，并且该字符串存放在常量区，只具有可读权限，因此一旦声明完成将不能再对字符本身进行修改,但是可以将字符串变量str指向另一个字符串(即允许对str重新赋值)；
                3：字符串不同声明方式的异同：
                    1：存储区域不同：
                        1：如果字符串以字符数组 char srt[n]的方式创建，那么该字符串是保存在全局数据区，可读可写，即可以对字符串本身进行修改；
                        2：如果字符串以字符指针 char *str的方式创建，那么本质上是创建了一个字符串常量，存放在常量区，只具有可读权限，即不能对字符串本身进行修改；
                    2：字符串名称意义不同：
                        1：如果字符串以字符数组 char srt[n]的方式创建，那么字符串变量名和字符数组名完全相同；即：在&运算符、sizeof运算符、字符数组声明时，字符串变量名代表的是字符串整体；其余情况均只能代表字符串首个字符的地址；
                        2：如果字符串以字符指针 char *str的方式创建，那么字符串本身以及字符串变量名均只能代表字符串首个字符的地址；即此时字符串本身以及字符串变量名都是个指针，指向字符串首个字符；并不能代表字符串整体；
                    3：实际保存时字符串内容不同：
                        1：如果字符串以字符数组 char srt[n]的方式创建时，字符数组中的字符数和创建的字符串字符数完全相同；
                        2：如果字符串以以字符指针 char *str的方式创建，那么实际保存字符串时会在字符串后面加一个'\0'来作为字符串的结束符号；实际保存该字符串数组的字符个数比字符串本身多1个字符；
                4：访问字符串中的字符：
                    1：数组的方式获取字符串中的字符：str1[0]; 或者：str6[n];
                    2：指针的方式获取字符串中的字符：*str1;   或者：*(str1+n);  
                5：字符串的长度：
                    1：使用sizeof(字符数组名)来查询字符串长度：
                        1：如果以字符数组的方式声明，则sizeof的值即为字符串字符个数；
                        2：如果以字符指针的方式声明，则sizeof的值为字符串字符个数+1(原因是：C语言中会在字符串后加上'\0'作为字符串的结束符号)：
                    2：使用string.h头文件中定义的strlen(字符数组名/字符串变量名)函数，该函数计算得到的长度则是字符串的实际长度！其余针对字符串操作的函数也是在string.h头文件中；
                6：对于字符串数组的理解：
                    1：字符串数组声明：char *str[]={"string1","strign2"}中：
                        第一问：为何需要声明成char *str[] 这种格式：
                            1：从指针方面理解：字符串本身以及字符串变量名本质上是一个指针，是指向字符串中首个字符的指针；因此字符串数组本质上是一个指针数组；等价于：
                                char * str_item1 = "string1";
                                char * str_item2 = "string2";
                                char *str[] = {srt_item1,str_item2};
                            所以：char *str[]代表声明一个字符指针数组；

                            2：从字符数组方面理解：字符串本质上都是一个字符数组，因此字符串数组本质上也可以看做是一个二维字符数组；等价于：
                                char str_item1[] = {'s','t','r','i','n','g','1','\0'}
                                char str_item2[] = {'s','t','r','i','n','g','2','\0'}
                                char *str[] = {str_item1,str_item2};
                            所以：char *str[] 代表声明一个二维字符数组；
                        
                    2：注意字符串数组声明：
                        char *str[] 指的是声明一个字符串数组；
                        char (*str)[] 指的是声明一个字符串数组指针，即二维字符数组指针，指向字符串数组中的某一个字符串的地址；

            结构体：
                1：结构体类型：
                    1：结构体属于复杂数据类型；类似于字典，元素是名称和值之间的映射，通过元素的名称来访问元素的值；
                    2：结构体的具体结构由用户自定义，结构体中每一个元素都由元素的数据类型、元素的名称、元素本身的值构成；
                    3：和数组相比，具有以下异同点：
                        不同点：
                            1：数组管理一组数据本身；结构体则管理一组名称和数据之间的映射；
                            2：数组通过元素的位置访问元素；结构体则通过元素的名称访问元素；
                            3：数组声明完成后将只能存放声明时指定数据类型的数据；结构体可以存放不同数据类型的数据；
                        相似点：
                            1：数组声明完成后其长度将会固定，元素个数不允许超过声明的长度；结构体声明完成之后其具体结构也将固定，只能按照声明的结构存放数据；
                            2：数组占用的内存长度由数组的元素以及元素的数据类型决定；结构体占用的内存长度同样由结构体成员的个数以及每一个成员的数据类型决定；
                    4：结构体本身只是一种类型，声明一种结构体仅是确定当前结构体的具体结构，并不占用内存空间；声明结构体变量则是为该变量按照结构体的结构分配内存空间的过程，因此结构体变量才会占用内存空间；
                    5：结构体和数组都是一种数据容器，仅仅是容器的内部结构和用途不同而已；
                
                2：结构体的声明：
                    1：声明结构体的过程就是确定一种结构体具体结构的过程；
                    2：结构体声明方式：
                        struct 结构体名称 {
                            数据类型 元素名称;
                            数据类型 元素名称;
                            ...
                        }
                    3：结构体声明方式的说明：
                        1：结构体声明需要使用struct关键字；
                        2：结构体名称必须符合C语言标识符命名规范；
                        3：结构体中的每一个成员都必须注明数据类型，成员名称；
                        4：结构体声明完成之后，该结构体的结构将固定，使用该结构体时，将只能按照声明时的结构(结构体成员数据类型，成员名称)来操作；
                
                3：结构体变量：
                    1：通过声明的结构体来创建的变量称之为结构体变量；
                    2：创建结构体变量的过程本质上是系统按照结构体结构分配内存空间的过程；
                    3：结构体变量声明方式：struct 结构体名 结构体变量名1，结构体变量名2；

                4：结构体指针：
                    1：结构体指针是指某个结构体变量在内存中的首地址；
                    2：结构体指针声明方式：struct 结构体名 * 结构体指针名;
                
                5：结构体变量名和结构体指针：
                    1：结构体变量名：和数组不同，结构体变量名无论何时，都表示整个结构体；
                    2：结构体指针：和数组不同，数组指针是指指向数组元素的指针，结构体指针是指指向整个结构体的指针，而不是结构体某个成员的指针；

                6：结构体数组：
                    1：结构体数组仍然只是一个普通的数组，只是数组中的每一个元素都是一个结构体；
                
                7：结构体成员的操作：
                    取值:1：结构体变量名.结构体成员名
                        2：结构体指针变量名->结构体成员名
                        3：*(结构体指针变量名).结构体成员名

                    赋值:1：结构体变量名.结构体成员名 = 值
                        2：结构体指针变量名->结构体成员名 = 值
                        3：(*结构体指针变量名).结构体成员名 = 值

                8：结构体占用内存空间大小分析：
                    1：结构体中每一个成员在内存中的存储是连续且有序的；
                    2：结构体占用内存空间的大小有可能是结构体中每个成员的数据类型在当前平台占用内存大小的总和；但是由于内存对齐的原因也有可能大于总和！
                    3：实际上cpu通过地址总线来访问内存，一次能处理几个字节的数据，就命令地址总线读取几个字节的数据(32位平台的cpu一次可以处理4个字节的数据，64位平台的cpu一次可以处理8个字节的数据)；每次可以读取的字节个数称之为步长
                    4：将一个数据尽量放在一个步长之内，避免跨步长存储，CPU即可一次读取到需要的数据，可以提高数据读取效率，这称为内存对齐；在32位平台默认以4字节对齐，在64位平台默认以8字节对齐；
                    5：c语言编译器为了提高数据的存取效率会自动根据平台进行内存对齐；因此会出现结构体存在存储缝隙的现象；出于该原因，结构体的大小是有可能大于结构体成员数据类型在该平台占用字节的总和！
                    6：示例：
                        struct tmp {
                            char name[10];
                            int length;
                        };
                        该结构体在win32位平台下，sizeof的值是16；多出的两个字节是由于32位平台内存以4字节对齐，前10个字节刚好差两个字节成功成为4的倍数，实现4字节对齐，因此name数组和length之间就存在两个字节的缝隙；
                    7：由于内存对齐的原因，结构体在声明时要特别注意不同数据类型成员之间的顺序，尽量拼凑成步长的整数倍！
                9：结构体占用空间大小的计算：需要使用sizeof获取结构体变量的大小，由于结构体本身只是模板，因此对结构体名使用sizeof将会报错；
            共用体：
                1：共用体类型：
                    1：共用体和结构体相同都是一种复杂数据类型，结构上类似字典，成员由名称和值组成；通过成员名称来访问成员值；
                    2：共用体中所有的成员占用一段公共的存储空间，同一时刻只能存储一个成员的数据；
                    3：共用体占用的空间大小是共用体成员中占用空间最大的成员占用的空间大小；
                2：共用体声明：
                    union 共用体名{
                        数据类型 成员名;
                        数据类型 成员名;
                            .
                            .
                    }
                
                3：共用体空间大小：
                    1：共用体中，由于各个成员共享同一段内存空间，因此一个共用体变量占用的内存大小是：共用体成员中占用内存空间最大的成员所占用的内存空间；如：
                    union data{
                        int    score;
                        char   name;
                        double id
                    };
                    union data a;
                    a变量是一个共用体类型的变量，该共用体中占用空间最大的是double类型的成员id;因此整个共用体占用的内存空间大小为8个字节；
                
                4：共用体的应用：
                    共用体可以用在多个成员大小相近，业务类型相似，但又不可能同时存在的情况下；
            位域： 
                1：位域特性： 
                    1：有些情况下，存储数据并不需要一个或者多个完整的字节，只需要占用一个或者几个二进制位即可，C语言针对这种情况提供了位域这种特性；更加节省内存空间！
                2：位域的使用方式：
                    2：位域用在结构体声明时指定某个成员所占用的二进制位数的！如：
                        struct bs{
                            unsigned int  m;
                            unsigned int n:4;
                            unsigned char ch:6;
                        }
                        说明：
                            1：使用位域时，在成员名称后面通过冒号 : 限制该成员占用的二进制位数；
                            2：如果成员没有使用位域，那么会按照成员的数据类型为成员分配存储空间；
                            3：如果成员使用了位域，那么将会按照其占据的二进制位个数分配存储空间，位域的大小不能超过成员数据类型在当前平台所占据的二进制位个数；
                            4：C语言标准中，只有int、unsigned int支持位域，但实际编译器中，char、unsigned char、以及enum类型均有支持
                3：位域的存储方式：
                    3：位域的存储：
                        C语言标准并未规定位域的存储方式，不同的编译器有不同的实现，但是都会尽量压缩存储空间；
                        1：具体规则如下：(重要)
                            1：当相邻成员类型相同时，
                                1：如果他们的位宽之和小于类型的sizeof大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；
                                2：如果他们的位宽之和大于类型的sizeof之和，由于内存对齐的原因，后面的成员将从新的存储单元开始存储，其偏移量为类型在当前平台的字节数大小的整数倍！
                                3：特别注意：位域的sizeof值是内存对齐之后所占用内存大小的值(至少4/8字节或者为其整数倍)！

                            2：当相邻成员的类型不同时，不同的编译器有不同的实现方案，GCC会压缩存储，VC/VS不会！
                            3：特别注意：位域成员往往不占用完整的字节，因此使用&取地址运算符获取位域成员地址没有任何意义，因为位域成员是以位为单位的，而地址则是字节的编号，不是位的编号！

                4：无名位域：
                    1：位域成员可以没有名称，只给出数据类型和所占用的位宽；
                        如：
                            struct bs{
                                int m: 12;
                                int  : 20;  //该位域成员不能使用
                                int n: 4;
                            };
                    2：无名位域一般用来做填充或者调整成员位置；因为没有名称，无名位域不能使用；  
        11：C语言数据类型别名：
            1：C语言可以通过同typedef为已有的数据类型定义别名；
            2：定义方式：typedef 已有数据类型名称 新名称；
            3：常见三种情况下定义别名：
                1：为基本数据类型定义别名(整数，浮点数，字符类型)：
                    如：声明：typedef int INTEGER;  那么INTEGER就代表int类型的数据
                        使用：INTEGER 1;            等价于int i;
                2：为指针、数组类型定义别名：
                    如：声明：typedef char newname[20];  那么newname就等同于一个char类型长度为20的数组；
                        使用：newname a1,a2;             等价于char a1[20],a2[20]
                3：为共用体、结构体定义别名：
                    如：声明：typedef struct stu{
                                char  *name;
                                short age;
                            } STU;                     那么STU就代表stu结构体；
                        使用：STU stu1;                  等价于struct stu stu1；
                    
        12：C语言函数：
            1：函数即定义的代码块，可以被重复调用；一个C源文件中可以有任意多个函数；
            2：函数的声明：
                返回值类型/void function_name(int a, int b){
                        code....
                }
                备注：  
                    1：函数声明要注明返回值类型，没有返回值时要写void；
                    2：函数名要遵守c语言标识符命名规范；推荐以小写加下划线方式命名；
                    3：形参需要通过数据类型 变量的方式声明，多个形参使用,隔开；如果为了防止形参在函数中被修改，可以使用const关键字将形参修饰为常量；
                    4：在函数体中使用return语句返回数据。
            3：形参：
                1：形参是函数在调用时必须传入的参数，要写在函数名称后面的()中；每一个形参要注明数据类型和名称，如果为了防止形参在函数中被修改，可以使用const修饰形参；多个形参以 , 分割；
                2：C语言中形参不允许赋初值；
                3：形参和实参在数量上，顺序上，类型上必须严格一致；
                4：函数调用中参数传递是单向的，即：只能将实参的值赋值给形参，形参实际是实参的拷贝，因此，形参的值发生改变并不会影响实参的值；
                5：形参的生命周期：
                    1：形参只有在函数调用时才会分配存储空间，调用结束之后，会立刻释放所占用的存储空间；
                    2：对于形参占用空间的释放，本质上只是弃之不用，并非清空；
                    3：对于指针类型的形参，函数执行结束之后，将会销毁指针类型形参变量的值，但是该指针所指向的存储空间中的内容并不会销毁；
                6：对于函数需要传入数组，结构体，共用体，函数，字符串等复杂的数据类型时，推荐传入指针；
            4：函数的返回值：
                1：函数中如果有返回值，那么需要在函数名称之前显式说明返回值的数据类型，如果没有返回值，则需要填写void;
                2：向外部返回返回值：
                    1：通过return语句返回一个返回值；函数中可以有多个return语句，但是仅仅只有第一个return语句才会执行；函数的调用者可以通过一个变量来接收函数中return语句的返回值；
                    2：通过全局变量来返回/接收返回值：即将返回值赋值给全局变量，函数调用者调用完函数之后，可以通过全局变量获取函数的返回值；
                    3：通过向被调用函数传入指针变量来获取返回值，由于函数在执行完成之后仅仅销毁形参变量本身，对于指针类型的形参变量，并不会销毁指针变量指向的存储空间中的值，因此可以利用指针类型的形参变量向外返回返回值；函数的调用者则通过传入的指针实参来获取函数的返回值；
            5：函数调用：
                1：函数通过函数的名称调用：函数名(实参) 即可调用；可以根据函数返回值的方法来接收函数的返回值；
                2：c语言的执行逻辑是从main函数开始执行，并从main函数尾部结束执行，而且是依次从上往下逐条执行；原则上函数的定义要出现在函数的调用之前；否则将会报错；
                3：如果函数在定义之前需要调用则需要先对函数进行声明；   
            6：函数的声明：
                1：声明方式：返回值类型 函数名 （类型 形参，类型 形参,...）;
                            或：
                            返回值类型 函数名 （类型,类型,...）;
                2：在函数调用之前有了函数的声明，函数实体将可以出现在任何地方，可以在其他文件，静态链接库，动态链接库；
            7：递归：
                1：函数中自己调用自己的过程称为递归；
                2：在函数中每递归一次，就等同于从新调用一次该函数；
                3：基于第二条，因此在递归中每递归一次，函数被调用一次，函数所使用到的局部变量都将被重新创建一次；并放在调用栈中！递归完成之后将会按照调用栈层层返回；
                4：基于第三条：递归的调用速度是低于循环的，而且占用额外的内存空间；由于递归会占用额外的空间，因此递归的深度取决于内存的大小；
                5：尾递归：函数的递归放置在最后一行，即：函数调用完自身后，原函数即结束，这样的递归称之为尾递归；
                6：尾递归的优势：基于2~3条，函数的递归深度取决于内存的大小，如果递归深度过深将会超过内存限制而出错！如果是尾递归，函数每进行下一次新的调用，上一次的函数执行即结束，函数调用栈中永远只有一个函数，不会超过内存限制！ 
            8：函数指针：
                1：函数在程序运行时，代码也被加载至内存中，并占用一段连续的存储单元；可以定义一个指针，指向存储函数代码的内存块的地址，通过该函数指针即可找到函数的内容，进而调用函数；这样的指针称之为函数指针，指针变量称之为函数指针变量；
                2：函数指针的声明形式：
                    returnType (*pointerName)(param list)
                    备注：
                        1：returnType指的是该函数的返回值类型；
                        2：pointerName是函数指针变量的名称；*pointerName指明该变量是一个指针类型的；(* pointerName)中的()必须带上！
                        3：param list是函数的形参列表；
                3：函数指针的调用：
                    (*pointerName)(实参列表);
                    调用方式说明：
                        *表名对pointerName的指针变量进行调用，由于()的运算优先级最高，所以*和pointerName必须使用()运算符，否则语义将会改变！
        13：C语言预处理：
            1：C语言预处理：
                1：是指在编译程序之前对代码进行一些预置的处理，包括头文件的包含、宏的定义、条件编译；
                2：对于头文件的包含、宏的定义、条件编译都是通过预处理命令来完成；

            2：头文件包含：#include
                1：为何要引入头文件：
                    1：C语言中在调用函数之前需要先对函数进行声明，而项目中有些函数和标准库函数的声明均在对应的头文件中，只有在使用之前，引入对应的头文件才能够合法调用对应的库函数；
                2：引入头文件的命令：
                    1：从系统路径下查找头文件：#include <头文件名.h> 
                    2：先从当前目录下查找头文件，如果未找到，则从系统路径下查找： #include "头文件名.h"
                    3：推荐使用<>来引入标准库头文件，使用""来引入自定义的头文件；
                3：头文件的引入方式：
                    1：引入头文件的过程就是将头文件的内容插入到引入该头文件的C源文件中；本质上和复制头文件内容然后粘贴在C源文件中引入该头文件命令处效果是一样的；
                4：头文件引入说明：
                    1：一个#include命令只能包含一个头文件，多个头文件需要多个#include命令来包含；
                    2：同一个头文件可以被多次引入，多次引入的效果和引入一次的效果相同，头文件在代码层面有放置重复引入的机制；
                    3：头文件允许嵌套引入，即在头文件中也可以使用#include来包含其他头文件；

            3：宏定义：
                1：宏：
                    1：宏是指：通过一个标识符在文件级别表示一个字符串；
                    2：这个标识符即为宏名，在程序中可以使用宏名来代替宏表示的字符串；
                    3：宏所代替的字符串是文件级别的字符序列，这些字符串在预处理阶段会作为文件内容原样替换掉宏名；并非程序意义上的字符串；
                2：宏的定义方式：
                    1：定义方式：#define 宏名 字符序列
                    2：对于宏定义的说明：
                        1：宏的定义需要使用#define这个预处理命令来定义；
                        2：宏的定义必须放在函数外部，其作用域在定义之后至程序结束；也可以使用#undef来提前结束其作用域；
                        3：宏名推荐使用大写，来和程序中的标识符做出区别，也可以使用小写；
                        4：字符序列是文件级别的字符序列，可以是任意内容；
                        6：宏的定义不是语句，无需再宏定义后面带上‘;’，如果带上了‘;’在预处理阶段，分号也会被当做宏的内容替换宏名；
                        7：宏定义允许嵌套，宏定义中的字符序列可以使用在当前宏定义之前已经定义好的宏；
                3：宏的使用注意事项：
                    1：宏会在预处理阶段被原模原样替换成宏所代表的字符序列，这个替换是本质上是文件内容上的替换，和程序无关；其正确性也只有在替换完成后的编译阶段才能够检查出；
                    2：代码中使用宏时直接使用宏名即可，不必为宏名带上引号，如果带上引号将会认为宏名是一个字符或者字符串，而不会被当做宏处理；
                    3：宏名的替换实际上是文件内容的替换，和直接将宏名写做宏后面的内容是完全一样的，因此在定义和使用宏的时候必须要注意，宏的内容替换掉宏名之后是否符合程序语法要求及编程目标；
                    4：特别注意，宏在替换之后的内容是否符合程序语法和编程目标，尤其在运算表达式中要特别注意替换之后的运算表达式是否符合运算的优先级一级运算表达式的正确性；
                4：带参数的宏定义：
                    1：C语言允许宏带有参数，宏定义中的参数同样称为形参，调用宏时传入的参数称之为实参；
                    2：定义方式：#define 宏名(形参列表) 字符序列
                    3：使用带有参数的宏：
                        1：宏的参数和程序中函数的参数并不相同；宏的参数仍然只是文件级别的字符；实参到形参，形参到字符序列均只是文件内容上字符之间的简单替换；
                        2：预处理阶段对宏替换时，会先使用实参字符串替换宏定义中字符序列中的形参，该替换过程只是简单的字符代换，然后再用替换掉形参符号之后的字符序列替换整个宏；
                        3：带有参数的宏在使用时需要向宏传入实参，该实参其实只是文件内容级别的字符而已，并非程序级别的参数，实参和形参之间只是简单的字符替换；
                    4：带有参数的宏定义注意事项：
                        1：宏名和形参列表之间必须紧紧挨在一起，不允许有任何空格，否则将认为该宏是一个不带参数的宏；
                        2：和普通的宏定义一样，必须注意到宏的替换仅仅只是文件内容上的替换，本质上就是使用一个字符序列表示另一些字符序列的过程；在替换时尤其注意替换完成之后的内容是否否和编程语法和编程目标；
                    5：宏参数和函数参数：
                        函数参数是程序级别上值的复制；宏参数只是文件内容级别上字符与字符之间的替换；
                    6：宏参数的处理：
                        1：为宏参数带上引号：#；
                            如：#define STR(s) #s; 程序中使用STR(qwe) 实际替换STR(qwe)时是使用"qwe"替换的；而不是#qwe
                        2：连接多个宏参数：##；
                            如：#define STR(S) #s##s; 程序中使用STR(qwe) 实际替换STR(qwe)时是使用"qwe"qwe替换的；而不是#qwe##qwe
                5：C语言中预定义的宏：
                    ANSI C 规定了以下几个预定义宏，它们在各个编译器下都可以使用：
                    __LINE__：表示当前源代码的行号；
                    __FILE__：表示当前源文件的名称；
                    __DATE__：表示当前的编译日期；
                    __TIME__：表示当前的编译时间；
                    __STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1；
                    __cplusplus：当编写C++程序时该标识符被定义。

            4：条件编译：
                1：可以通过预处理命令来调整程序的编译方式；主要用在根据不同的条件/宏，来编译不同的代码；
                2：条件编译命令：
                    1：根据条件表达式来编译不同的代码：
                        #if 整型常量表达式1
                            程序段1
                        #elif 整型常量表达式2
                            程序段2
                        #elif 整型常量表达式3
                            程序段3
                        #else
                            程序段4
                        #endif

                    2：根据宏来编译不同的代码：
                        #ifdef  宏名
                            程序段1
                        #else
                            程序段2
                        #endif
                        或者：
                        #ifndef  宏名
                            程序段1
                        #else
                            程序段2
                        #endif
                3：可以通过#error error_message来向外传递编译期间不符合编译条件的错误信息；

        14：C语言错误处理：
            1：C语言中，对于错误的处理并不会像其他语言一样使用try...catch来捕获并处理；而是使用 errno 全局变量来记录函数调用发生的错误码；并且可以通过strerror()和perror()来获取错误码对应的错误原因描述；
            2：C语言中的函数调用在执行成功时会返回EXIT_SUCCESS,其值为0，表示函数执行成功，执行期间未发生错误；执行失败时会返回EXIT_FAILURE,其值为1，并且在返回1的同时将错误码设置给errno全局变量；因此可以通过errno全局变量来判断函数执行期间是否发生错误；
            3：关于error全局变量的使用：
                1：errno全局变量以及所有的错误码均定义在error.h头文件中，在使用时需要先引入error.h头文件；
                2：errno如果为0，表示函数调用未发生错误；如果是具体的错误码，则可以调用perror()和strerror()获取具体错误原因；但是函数如果执行成功，并不会主动设置errno为0，也不会设置为其他值；而是保持上一次发生错误的函数对该变量设置的值；
                3：由于函数并不会主动置errno变量为0，因此在使用errno判断函数是否发生错误之前，建议先对函数的返回值进行检测，然后再使用errno来获取具体错误原因；如果函数返回值不能判断函数是否发生错误，那么在使用errno检测本次函数调用错误状况时，需要先对其置0；
                4：对于单线程程序而言，errno全局变量不存在线程共享的情况，因此在使用errno时，只需保证errno没有被重新定义即可；但是对于多线程而言，编译器为了保证每个线程有独立于线程的errno变量，通过extern int*__errno_location（void）__THROW__attribute__((__const__));”与“#define errno(*__errno_location())定义，因此在多线程中使用errno必须保证 __ASSEMBLER__ 没有被定义，同时 _LIBC 没被定义或定义了 _LIBC_REENTRANT；
                5：避免使用errno来检测文件流错误，而是通过检测文件标识符是否为NULL来检测文件打开是否出错；
                6：库函数的正确执行，也不能保证errno不会被修改；
            4：关于perror()和strerror()：
                1：对于perror(char * message):用来打印当前错误码对应的错误信息；该函数定义在stdio.h头文件中。调用该函数时可以向perror传入一个说明字符串，在打印时，该函数会先打印传入的说明字符串，然后打印当前错误码对应的错误原因；
                2：对于strerror(int errno):用来获取指定错误码对应的错误信息；该函数定义在string.h头文件中。调用该函数时可以向strerror传入一个错误码，该函数会返回给定错误码对应的错误原因；

        15：C语言断言：
        16：C多文件编程：
    三：C语言标准库：

    四：C语言高级部分：
        1：C语言内存具体操作：
            1：关于内存：
                1：物理内存：
                    1：物理内存是指真实的内存条，即内存硬件资源；
                    2：内存资源的组织方式：
                        1：内存资源在计算机中被分割为若干个1字节大小的存储单元；每一个存储单元都有一个编号，称之为存储单元的地址或者内存地址；由于其表示的是物理内存的地址，因此称之为物理地址；该物理内存地址以16进制unsigned int类型的数据表示，最小值从0开始；
                        2：物理内存的地址仍然是对硬件内存资源的抽象，并不代表真实硬件的结构；
                2：虚拟内存：
                    1：虚拟内存优势：
                        计算机中并不会让程序直接访问真实的物理内存，而是在物理内存和应用程序之间提供了一个抽象层：虚拟内存；使用虚拟内存有以下几个优势：
                        1：虚拟内存为每一个进程都提供了一段内存地址范围相同的内存空间；可以简化程序对于内存的管理和使用；
                            1：程序只需要关注自己可用的虚拟内存空间即可，无需关心虚拟地址上的数据存储在哪个真实的物理地址上；
                            2：程序无需担心当前地址是否已经被别的进程已使用，只需关注对内存本身的使用即可；
                            3：程序无需关心当前内存资源是否足够，如果不够，系统将会通过换入换出来腾出足够的空间给进程使用；
                        2：虚拟内存保证了每一个进程的内存空间都是独立的私有的，不允许其他进程访问当前进程的地址空间，也不允许当前进程访问其他进程的地址空间；
                            1：有了虚拟内存的存在，真实的物理内存交由内核管理，内核会负责对进程访问的内存地址权限以及范围进行检查，避免当前进程破坏其他进程，或者当前进程被其他进程破坏；
                    2：虚拟内存的组织方式：
                        1：虚拟内存仍然被组织为若干个1字节大小的存储单元，每一个存储单元都有一个编号，同样称之为内存地址，从0开始，以16进制unsigned int类型的数据表示，但是该内存地址是虚拟内存的地址，并不是真实物理内存的地址，因此又称之为虚拟地址；
                        2：虚拟地址的最大值由硬件和操作系统决定：
                            1：对于32位系统，最大的虚拟地址值为2的32次方；因此其内存地址范围也在0~2^32之间，即范围是0~0XFFFFFFFF，空间大小是4GB；
                            2：对于64位系统，最大的虚拟地址为2的64次方，但是由于2^64次方是一个相当大的数字，实际按照现有的技术物理内存和CPU的寻址能力以及应用程序对于内存空间的需求不可能有这么大，所有并未完全使用2^64次方作为最大虚拟地址值，而是使用低48位作为虚拟地址的最大值；即对于64位的编译模式，其虚拟地址最大值为2^48，空间大小为256TB；
                3：虚拟内存和物理内存的映射关系：

            2：进程对内存的使用：
                1：内存模型：进程内存在虚拟地址空间中的分布情况：
                    1：对于32位环境，一个进程可用的虚拟地址空间为4GB；其中高地址的1GB(windows中为高地址的2GB)需要分配给内核使用，低地址的3GB(windows中为低地址的2GB)空间才能够被应用程序使用；
                    2：给内核使用的1GB空间称之为内核空间，给应用程序使用的3GB空间称之为用户空间；
                    3：给应用程序使用的3GB空间从高地址向低地址被分割为：栈区、动态链接库、堆区、全局数据区、常量区、程序代码区、一部分保留区域：
                        栈区：
                            功能：
                                存放函数的形参值、普通局部变量值等；
                            分配和释放：可以静态分配也可以动态分配，单都由编译器自动释放，无需手动释放；
                                静态分配：如函数的形参，普通局部变量等都是在函数运行期间，由编译器自动分配内存空间，并在函数运行结束之后，由编译器释放分配的内存空间；
                                动态分配：栈区也可以使用alloc函数来手动申请分配；但是alloc手动分配的内存空间仍然是由编译器自动释放的；
                            分配效率：
                                计算机底层一般会对栈提供支持，比如分配专门的寄存器存放栈的地址，并且压栈出栈都有专门的指令，因此栈的分配效率比较高；
                            分配大小：
                                栈的容量是由操作系统预先规定好的，但是可以通过编译器来修改当前程序栈区的大小；栈区一般比较小，linux默认栈区是8MB；如果程序中对栈区的申请超过该值，将会报栈溢出错误；
                            分配方式：
                                栈区占用一段连续的内存区域，并且其分配方向是从高地址向低地址分配；
                            内存碎片：
                                栈区分配时从栈顶开始分配，分配多大的内存空间就移动多少栈顶位置，并且函数先调用先分配，调用完成即释放，不存在内存碎片问题；
                            数据读写：
                                具有可读写权限；即可以新增数据，修改数据，读取数据；
                            其他：
                                计算机中栈区的拥有单位是线程，即每一个线程都将拥有一个栈区；
                        堆区：
                            功能：
                                存放手动分配内存空间的变量值；
                            分配和释放：
                                只能由编程者手动申请分配和手动释放，如果未手动释放，那么程序运行完毕之后由操作系统回收；
                            分配效率：
                                堆区的分配操作由函数库提供实现，并没有CPU底层的支持；并且在分配堆空间时，因为复杂的分配策略进一步导致分配效率降低；
                            分配大小：
                                操作系统使用链表存储空闲地址，同时链表的遍历方向是从低地址想高地址进行，因此堆内存的申请大小主要取决于系统中有效的虚拟内存大小；
                            分配方式：
                                需要先从低地址向高地址方向遍历空闲地址链表，并判断该地址空间空间大小是否大于申请空间，找到首个空闲空间大于申请空间的地址时，为程序分配该段内存空间，并将该地址从空闲链表中删除，然后该空闲空间分配之后多余的空间地址重新添加至空闲链表中；
                            内存碎片：
                                由于堆内存分配时机和释放时机的不确定，每次分配的大小不确定，分配的位置不确定等等原因最终造成堆内存地址碎片化严重；分配效率下降；
                            数据读写：
                                具有可读写权限；即可以新增数据，修改数据，读取数据；
                        全局数据区：
                            功能：
                                存放全局变量，静态局部变量等；
                            分配和释放：
                                由编译器在编译阶段分配地址，程序运行时分配内存空间，程序运行完成后释放内存空间；
                            数据读写：
                                具有可读写权限；即可以新增数据，修改数据，读取数据；
                        常量区：
                            功能： 
                                存放const常量和字符串常量；
                            分配和释放：
                                由编译器在编译阶段分配地址，程序运行时分配内存空间，程序运行完成后释放内存空间；
                            数据读写：
                                常量区的数据只能读取或者新增，不能修改已有的数据本身；
                        程序代码区：
                            功能：
                                存放程序的二进制代码
                        动态链接库：
                            功能：
                                该区域一般存放加载的动态链接库(如果使用到的话)
                    4：对于64位环境的内存模型：
                        64位环境的内存模型和32位的基本一致，区别在于：
                            1：64位环境下，虚拟地址空间大小为256TB，linux将高128TB的空间分配给内核使用，而将低128TB的空间分配给用户程序使用；
                            2：由于64位环境下，虚拟地址空间只有48位有效，因此，为了防止出错，系统规定任虚拟地址的48位至63位必须与47位一致；这样将会有一部分空间被空出来，无法被访问到；
            3：内存对齐：
                1：理论上CPU可以直接访问任意地址的存储单元，但实际上为了数据读取效率，会对读取方式做优化，并非任意一个存储单元都可以被CPU直接读取；
                2：CPU通过地址总线来在内存上定位数据，CPU一次能够处理多少字节的数据，就会命令地址总线读取多少字节的数据，充分利用地址总线对于数据的读取机会；
                3：对于32位的CPU，一次可以处理4个字节的数据，地址总线将会按照地址为4的倍数一次读取4个字节的数据，比如从地址0,4,8,12等来读取数据，一次读取4个字节；对于64位的CPU一次可以处理8个字节的数据，地址总线将会按照地址为8的倍数一次读取8个字节的数据，比如从地址0,8,16,24等来读取数据；
                4：地址总线一次能够读取的最大字节数称之为步长，尽量将数据放在一个步长之内，比如对于32位：将int类型的数据放在0~4内，即可一次读取完，如果该int类型的数据起始地址为3，那么地址总线就需要读取两次才能拿到完整的数据；因此将数据放在一个步长之内，避免跨步长存储，导致读取数据效率降低，这种存储方式称之为内存对齐；
                5：内存对齐经常使用在结构体中；虽然使用内存对齐有时候会增加对内存的占用，但是提升了数据的读取效率；
                6：内存对齐的长度由CPU决定，但具体的对齐方式由编译器实现，因此在64位平台上使用32位的方式编译程序，改程序仍然以4字节对齐；
            4：内存操作：
                1：C语言切近硬件，支持直接对内存地址操作；C语言中对内存操作函数的声明均放在stdlib.h头文件中，使用时需要先引入stdlib.h头文件；
                2：内存分配相关函数：
                    1：void *malloc(size_t size);
                        功能：向系统申请size字节大小的存储空间，系统将会从堆内存区域分配size个字节的存储空间，并将该存储空间的首地址返回；
                        参数：szie:需要申请的存储空间大小，以字节为单位。
                        返回值：如果系统分配存储空间失败，将返回NULL，
                                如果系统分配存储空间成功，将返回该存储空间的首地址，即第一个存储单元的地址；
                        说明：
                            1：该函数申请的size个存储单元地址是连续的；
                            2：该函数不会对申请的内存空间进行初始化，在使用之前务必手动进行初始化；
                            3：该函数是从堆内存中分配存储空间；使用完毕之后务必手动释放；

                    2：void * calloc (size_t num, size_t size );
                        功能：向系统申请num个相邻存的储空间，每个存储空间的字节数为size，系统将会从堆内存区域分配num*size个字节的存储空间，并将该存储空间的首地址返回；
                        参数：num：存储空间的个数；
                            szie:需要申请的存储空间大小，以字节为单位。
                        返回值：如果系统分配存储空间失败，将返回NULL，
                                如果系统分配存储空间成功，将返回该存储空间的首地址，即第一个存储单元的地址；
                        说明：
                            1：系统分配的num个存储空间地址是连续的；
                            2：该函数等价于使用malloc函数申请num*size个字节的存储空间，即等价于:malloc(num*szie)
                            3：该函数和malloc不同点在于，calloc申请的存储空间会被自动初始化为0，malloc申请的存储空间不会初始化，需要手动初始化；
                            4：该函数是从堆内存中分配存储空间；使用完毕之后务必手动释放；

                    3：void * realloc (void * ptr, size_t size );
                        功能：调整已经分配好的存储空间的大小
                        参数：ptr:原先已经分配好的存储空间的首地址(待调整存储空间的首地址，必须是malloc、calloc、realloc返回的返回值);
                            size:调整目标大小(即：本次调整完之后该存储空间的大小，以字节为单位)
                        返回值：调整失败返回NULL；
                            调整成功返回调整之后的存储空间的首地址；
                        说明：
                            1：在对原存储空间缩容时，原存储空间中的内容不会改变，并且直接返回原存储空间的首地址ptr；
                            2：在对原存储空间扩容时，首先会检测原存储空间之后是否还有多余的空间能够将目前的存储空间扩展至目标大小：分为以下两种情况：
                                1：如果能够直接在原存储空间之后扩容，那么扩容完成之后将直接返回原存储空间的首地址(即存储空间的首地址不变);
                                2：如果源存储空间之后的连续空间大小不足以将源存储空间扩容至目标大小，那么将会从新分配一段size字节大小的存储空间，然后将原存储空间中的内容拷贝至新的存储空间，并将新的存储空间的首地址返回；
                            3：该函数是从堆内存中分配存储空间；使用完毕之后务必手动释放；
                    4：void * alloc(size_t size);
                        功能：向系统申请size个字节大小的存储空间，系统将会从栈内存中分配size个字节大小的存储空间，并将该存储空间的首地址返回；
                        参数：size需要分配的存储空间大小，以字节为单位；
                        返回值：如果分配失败，将会返回NULL；
                            如果分配成功，将会返回该存储空间的首地址；
                        说明：
                            1：该函数分配的size个字节大小的存储空间地址连续；
                            2：该函数是从栈内存中分配的，而非堆内存；
                            3：由于该函数分配的内存空间是从栈内存中分配的，因此该函数分配的内存空间无需手动回收，将会由程序自动释放；
                    5：void free(void *ptr);
                        功能：释放由malloc()、calloc()、relloc()申请的内存空间；
                        参数：ptr：由malloc()、calloc()、relloc()返回的内存空间地址；
                        返回值：无返回值
                        说明： 
                            1：每一个内存分配函数(除过alloc())都必须要有free函数释放申请的内存空间；
                            2：内存空间的释放和申请必须在同一个抽象层级/模块/函数中；
                            3：使用free()函数释放内存空间之后，原来指向该内存空间的指针并不会被自动置为NULL。所以在使用free之后必须手动将指向内存空间的指针置为NULL；
                            4：不要对free函数释放之后的内存进行操作；
                    5：对于内存分配函数的使用注意事项：
                        1：必须对内存分配函数的返回值做检查;
                            1：上述malloc、calloc、realloc、alloc函数在内存空间分配成功之后返回内存空间的首地址，分配失败之后返回NULL；因此上述函数调用之后必须对返回值做检查，防止对NULL指针操作；除此之外，在使用内存空间地址作为实参的函数中还应该在函数开始处使用assert(ptr != NULL)来做检查，防止对NULL指针操作；
                        2：内存的申请和释放必须在同一个抽象层次或者同一个模块/函数中进行；
                            1：内存的申请和释放如果不在同一抽象层级或者同一个模块/函数中进行，会导致多次释放的问题；也不利于程序的阅读和维护；
                        3：必须将内存分配函数返回的指针强制转换为被分配类型的指针；
                            1：内存分配函数返回的指针是void *类型，即该指针仅仅只表示内存空间的首地址，无任何数据类型；在实际使用时必须将该void *类型的指针转换为具体数据类型的指针；并且推荐在申请内存时就对其进行转换；如：
                            char *p = (char *)malloc(10 * sizeof(char));
                        4：在对指针进行操作时，必须确保指针指向的是一块合法的内存区域，严禁对值为NULL的指针进行操作；
                            1：在以下几种情况中：
                                1：无论是全局指针变量，还是局部指针变量；
                                2：无论是基本数据类型的指针变量，还是复杂数据类型的指针变量；
                                3：无论单独的指针变量，还是复杂数据类型中嵌套的指针变量；
                                在使用指针变量之前该指针变量的指向和数据类型必须明确；
                            2：使用指针变量之前必须对其类型和指向初始化，方式有以下两种：
                                对于指针变量的数据类型：
                                    1：在声明指针变量时即确定指针变量的类型；
                                    2：对void *类型的指针变量强制类型转换；
                                对于指针变量的指向：
                                    1：直赋值为具体的内存地址(其他指针的值)；
                                    2：使用内存分配函数向系统申请内存空间；  
                        5：确保为对象分配足够的内存空间； 
                        6：禁止执行0长度的内存分配；
                        7：可以使用宏定义简化内存分配函数的使用：
                            /*malloc*/
                            #define MALLOC_ARRAY(number, type) ((type *)malloc((number)* sizeof(type)))
                            #define MALLOC_FLEX(stype, number, etype) ((stype *)malloc(sizeof(stype) + (number)* sizeof(etype)))

                            /*calloc*/
                            #define CALLOC(number, type) ((type *)calloc(number, sizeof(type)))

                            /*realloc*/
                            #define REALLOC_ARRAY(pointer, number, type) ((type *)realloc(pointer, (number)* sizeof(type)))
                            #define REALLOC_FLEX(pointer, stype, number, etype) ((stype *)realloc(pointer, sizeof(stype) + (number)* sizeof(etype)))
                        
        2：C语言文件操作
        3：C语言多线程编程
        4：C语言多进程编程
        5：C语言网络编程
       

