1：程序和进程：
    1：程序：存储在磁盘上的程序代码文件；
    2：进程：正在运行中的程序；
2：进程中的内存地址：
    1：进程中变量的地址：
        1：全局变量(普通全局变量和静态全局变量)以及静态局部变量的地址是在编译阶段就已经确定的，无论何时运行，这些变量的内存地址都不会变；
        2：形参的地址和普通局部变量的地址是在程序运行时动态确定的；
    2：变量的地址和真实的物理内存：
        1：进程中变量的内存地址都是虚拟地址，并非真实物理地址；虚拟地址需要通过CPU根据内存映射机制转换才能得到真实物理地址；
        2：程序每次运行时，操作系统都会重新安排虚拟地址对应的真实物理地址；
    3：使用虚拟地址的优势：虚拟地址就是真实物理内存和应用程序之间的中间层，应用程序通过中间层操作内存有以下优势：
        1：使不同程序的地址空间互相隔离；
            隔离之后，编写程序时只需要关注当前程序对于内存的操作即可，无需关心当前程序是否受其他程序影响或者影响其他程序，只关注当前程序对内存的使用即可，简化了程序中对内存的操作；
        2：把内存管理权限交回给操作系统；
            交由操作系统管理内存之后，可以保证内存操作的安全性，如：使保存数据的内存无执行权限，保存代码的内存无修改权限等；
3：CPU和内存：
    1：关于CPU的执行效率：
        1：CPU的数据处理能力由CPU的主频和CPU单次处理数据的大小共同决定；CPU的主频是指单位时间内能够处理数据的次数，CPU一个时钟内能处理的数据大小由CPU中寄存器位数和主板的数据总线宽度决定；
        2：通常所说的32位/64位CPU是指CPU中寄存器的位数是32位还是64位；寄存器位数越大，表示寄存器中能够存储更多的数据，CPU对于数据的处理能力也越强；
        3：数据总线位于主板上，不在CPU中，也不由CPU决定，CPU的寄存器位数决定了其能够支持数据总线的最大宽度；一般情况下数据总线的宽度和寄存器位数相同；
    2：关于数据总线和地址总线：
        1：数据总线:数据总线用来在CPU和内存之间传输数据；
        2：地址总线：地址总线用来在内存上定位数据；
        数据总线和地址总线并无关系，宽度并不一定相等；地址总线的宽度往往会随着数据总线的宽度增长；
4：编译模式：
    程序中的所有变量都对应有一个内存地址，对应的内存地址是在虚拟地址空间中分配的，虚拟地址空间的大小决定了程序能够使用多大的内存空间；虚拟地址空间的大小则和具体的编译模式有关：
    1：32位编译模式：
        1：32位编译模式下，一个指针或者地址占用4个字节的内存，共有32位，理论上能够访问的虚拟内存空间大小为2的32次方，即0X100000000 Bytes，即4GB；有效的虚拟地址范围是0~0XFFFFFFFF;
        2：在32位编译模式下，无论实际的物理内存由多大，能够使用的虚拟地址空间范围只有0~0XFFFFFFFF，一个程序能够使用的最大内存空间只有4GB，和实际的物理内存大小无关；
        3：如果应用程序实际使用的内存超过4GB，那么操作系统会将这4GB的内存中暂时不用的数据先写入到磁盘，腾出内存空间给程序使用；
    2：64位编译模式：
        1：64位编译模式下，一个指针或者地址占用8个字节的内存，共有64位，理论上能够访问的虚拟内存空间大小为2的64次方；但是该值是一个相当大的数字，实际中的物理内存按照现有的技术不可能达到这么大，CPU的寻址能力也没有这么大，应用程序对于内存空间的需求同样也很少能够有这么大，因此实现64位长的虚拟地址只会增加系统的复杂度和地址转换的成本，并不会带来很可观的性能提升；
        2：在实际的64位编译模式中，windows和linux都对虚拟地址进行了限制，仅使用虚拟地址的低48位，总得虚拟地址空间为2的48次方；即：256TB；即64位编译模式下，一个应用程序能够使用的虚拟地址空间最多只有256TB，但是实际中的内存大小很少有这么大，实际能够使用的内存取决于真实的内存大小;

5：C语言内存对齐：
    1：内存在系统中被分割为若干个1字节大小的存储单元，每一个存储单元都会有一个编号，这个编号称之为存储单元的地址或者内存地址；理论上CPU可以直接访问任意地址的存储单元，但实际上为了数据读取效率，会对读取方式做优化，并非任意一个存储单元都可以被CPU直接读取；
    2：CPU通过地址总线来在内存上定位数据，CPU一次能够处理多少字节的数据，就会命令地址总线读取多少字节的数据，充分利用地址总线对于数据的读取机会；
    3：对于32位的CPU，一次可以处理4个字节的数据，地址总线将会按照地址为4的倍数一次读取4个字节的数据，比如从地址0,4,8,12等来读取数据，一次读取4个字节；对于64位的CPU一次可以处理8个字节的数据，地址总线将会按照地址为8的倍数一次读取8个字节的数据，比如从地址0,8,16,24等来读取数据；
    4：地址总线一次能够读取的最大字节数称之为步长，尽量将数据放在一个步长之内，比如对于32位：将int类型的数据放在0~4内，即可一次读取完，如果该int类型的数据起始地址为3，那么地址总线就需要读取两次才能拿到完整的数据；因此将数据放在一个步长之内，避免跨步长存储，导致读取数据效率降低，这种存储方式称之为内存对齐；
    5：内存对齐经常使用在结构体中；虽然使用内存对齐有时候会增加对内存的占用，但是提升了数据的读取效率；
    6：内存对齐的长度由CPU决定，但具体的对齐方式由编译器实现，因此在64位平台上使用32位的方式编译程序，改程序仍然以4字节对齐；



