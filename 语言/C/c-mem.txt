1：计算机内存：
    1：物理内存：
        1：物理内存是指真实的内存条，即内存硬件资源；
        2：内存资源的组织方式：
            1：内存资源在计算机中被分割为若干个1字节大小的存储单元；每一个存储单元都有一个编号，称之为存储单元的地址或者内存地址；由于其表示的是物理内存的地址，因此称之为物理地址；该物理内存地址以16进制unsigned int类型的数据表示，最小值从0开始；
            2：物理内存的地址仍然是对硬件内存资源的抽象，并不代表真实硬件的结构；
    2：虚拟内存：
        1：虚拟内存优势：
            计算机中并不会让程序直接访问真实的物理内存，而是在物理内存和应用程序之间提供了一个抽象层：虚拟内存；使用虚拟内存有以下几个优势：
            1：虚拟内存为每一个进程都提供了一段内存地址范围相同的内存空间；可以简化程序对于内存的管理和使用；
                1：程序只需要关注自己可用的虚拟内存空间即可，无需关心虚拟地址上的数据存储在哪个真实的物理地址上；
                2：程序无需担心当前地址是否已经被别的进程已使用，只需关注对内存本身的使用即可；
                3：程序无需关心当前内存资源是否足够，如果不够，系统将会通过换入换出来腾出足够的空间给进程使用；
            2：虚拟内存保证了每一个进程的内存空间都是独立的私有的，不允许其他进程访问当前进程的地址空间，也不允许当前进程访问其他进程的地址空间；
                1：有了虚拟内存的存在，真实的物理内存交由内核管理，内核会负责对进程访问的内存地址权限以及范围进行检查，避免当前进程破坏其他进程，或者当前进程被其他进程破坏；
        2：虚拟内存的组织方式：
            1：虚拟内存仍然被组织为若干个1字节大小的存储单元，每一个存储单元都有一个编号，同样称之为内存地址，从0开始，以16进制unsigned int类型的数据表示，但是该内存地址是虚拟内存的地址，并不是真实物理内存的地址，因此又称之为虚拟地址；
            2：虚拟地址的最大值由硬件和操作系统决定：
                1：对于32位系统，最大的虚拟地址值为2的32次方；因此其内存地址范围也在0~2^32之间，即范围是0~0XFFFFFFFF，空间大小是4GB；
                2：对于64位系统，最大的虚拟地址为2的64次方，但是由于2^64次方是一个相当大的数字，实际按照现有的技术物理内存和CPU的寻址能力以及应用程序对于内存空间的需求不可能有这么大，所有并未完全使用2^64次方作为最大虚拟地址值，而是使用低48位作为虚拟地址的最大值；即对于64位的编译模式，其虚拟地址最大值为2^48，空间大小为256TB；
        3：虚拟内存和物理内存的映射关系：

    3：进程对内存的使用：
        1：内存模型：进程内存在虚拟地址空间中的分布情况：
            1：对于32位环境，一个进程可用的虚拟地址空间为4GB；其中高地址的1GB(windows中为高地址的2GB)需要分配给内核使用，低地址的3GB(windows中为低地址的2GB)空间才能够被应用程序使用；
            2：给内核使用的1GB空间称之为内核空间，给应用程序使用的3GB空间称之为用户空间；
            3：给应用程序使用的3GB空间从高地址向低地址被分割为：栈区、动态链接库、堆区、全局数据区、常量区、程序代码区、一部分保留区域：
                栈区：
                    功能：
                        存放函数的形参值、普通局部变量值等；
                    分配和释放：可以静态分配也可以动态分配，单都由编译器自动释放，无需手动释放；
                        静态分配：如函数的形参，普通局部变量等都是在函数运行期间，由编译器自动分配内存空间，并在函数运行结束之后，由编译器释放分配的内存空间；
                        动态分配：栈区也可以使用alloc函数来手动申请分配；但是alloc手动分配的内存空间仍然是由编译器自动释放的；
                    分配效率：
                        计算机底层一般会对栈提供支持，比如分配专门的寄存器存放栈的地址，并且压栈出栈都有专门的指令，因此栈的分配效率比较高；
                    分配大小：
                        栈的容量是由操作系统预先规定好的，但是可以通过编译器来修改当前程序栈区的大小；栈区一般比较小，linux默认栈区是8MB；如果程序中对栈区的申请超过该值，将会报栈溢出错误；
                    分配方式：
                        栈区占用一段连续的内存区域，并且其分配方向是从高地址向低地址分配；
                    内存碎片：
                        栈区分配时从栈顶开始分配，分配多大的内存空间就移动多少栈顶位置，并且函数先调用先分配，调用完成即释放，不存在内存碎片问题；
                    数据读写：
                        具有可读写权限；即可以新增数据，修改数据，读取数据；
                    其他：
                        计算机中栈区的拥有单位是线程，即每一个线程都将拥有一个栈区；
                堆区：
                    功能：
                        存放手动分配内存空间的变量值；
                    分配和释放：
                        只能由编程者手动申请分配和手动释放，如果未手动释放，那么程序运行完毕之后由操作系统回收；
                    分配效率：
                        堆区的分配操作由函数库提供实现，并没有CPU底层的支持；并且在分配堆空间时，因为复杂的分配策略进一步导致分配效率降低；
                    分配大小：
                        操作系统使用链表存储空闲地址，同时链表的遍历方向是从低地址想高地址进行，因此堆内存的申请大小主要取决于系统中有效的虚拟内存大小；
                    分配方式：
                        需要先从低地址向高地址方向遍历空闲地址链表，并判断该地址空间空间大小是否大于申请空间，找到首个空闲空间大于申请空间的地址时，为程序分配该段内存空间，并将该地址从空闲链表中删除，然后该空闲空间分配之后多余的空间地址重新添加至空闲链表中；
                    内存碎片：
                        由于堆内存分配时机和释放时机的不确定，每次分配的大小不确定，分配的位置不确定等等原因最终造成堆内存地址碎片化严重；分配效率下降；
                    数据读写：
                        具有可读写权限；即可以新增数据，修改数据，读取数据；
                全局数据区：
                    功能：
                        存放全局变量，静态局部变量等；
                    分配和释放：
                        由编译器在编译阶段分配地址，程序运行时分配内存空间，程序运行完成后释放内存空间；
                    数据读写：
                        具有可读写权限；即可以新增数据，修改数据，读取数据；
                常量区：
                    功能： 
                        存放const常量和字符串常量；
                    分配和释放：
                        由编译器在编译阶段分配地址，程序运行时分配内存空间，程序运行完成后释放内存空间；
                    数据读写：
                        常量区的数据只能读取或者新增，不能修改已有的数据本身；
                程序代码区：
                    功能：
                        存放程序的二进制代码
                动态链接库：
                    功能：
                        该区域一般存放加载的动态链接库(如果使用到的话)
            4：对于64位环境的内存模型：
                64位环境的内存模型和32位的基本一致，区别在于：
                    1：64位环境下，虚拟地址空间大小为256TB，linux将高128TB的空间分配给内核使用，而将低128TB的空间分配给用户程序使用；
                    2：由于64位环境下，虚拟地址空间只有48位有效，因此，为了防止出错，系统规定任虚拟地址的48位至63位必须与47位一致；这样将会有一部分空间被空出来，无法被访问到；
    1：进程中变量的地址：
        1：全局变量(普通全局变量和静态全局变量)以及静态局部变量的地址：
            1：全局变量和静态局部变量的地址是在编译阶段就已经确定的，无论何时运行，这些变量的内存地址都不会变；
            2：全局变量和静态局部变量的内存空间都是在全局数据区；
            3：全局变量和静态局部变量的地址均是虚拟地址，并非实际物理地址；
        2：形参和普通局部变量：
            1：形参和普通局部变量的地址是在程序运行时动态确定的；
            2：形参和普通局部变量的内存空间都是在栈区；
            3：形参和普通局部变量的地址均是虚拟地址，并非物理地址；
        3：const常量和字符串常量：
            1：const常量和字符串常量无论是在顶层定义还是函数中定义，其地址都是在编译阶段确定好的，无论何时运行，其内存地址都不会变化；
            2：const常量和字符串常量的内存空间都是在常量区，只有读取和新增权限，无修改权限；
            3：const常量和字符串常量的内存地址均是虚拟地址，并给物理地址；

3：CPU和内存：
    1：关于CPU的执行效率：
        1：CPU的数据处理能力由CPU的主频和CPU单次处理数据的大小共同决定；CPU的主频是指单位时间内能够处理数据的次数，CPU一个时钟内能处理的数据大小由CPU中寄存器位数和主板的数据总线宽度决定；
        2：通常所说的32位/64位CPU是指CPU中寄存器的位数是32位还是64位；寄存器位数越大，表示寄存器中能够存储更多的数据，CPU对于数据的处理能力也越强；
        3：数据总线位于主板上，不在CPU中，也不由CPU决定，CPU的寄存器位数决定了其能够支持数据总线的最大宽度；一般情况下数据总线的宽度和寄存器位数相同；
    2：关于数据总线和地址总线：
        1：数据总线:数据总线用来在CPU和内存之间传输数据；
        2：地址总线：地址总线用来在内存上定位数据；
        数据总线和地址总线并无关系，宽度并不一定相等；地址总线的宽度往往会随着数据总线的宽度增长；
4：编译模式：
    程序中的所有变量都对应有一个内存地址，对应的内存地址是在虚拟地址空间中分配的，虚拟地址空间的大小决定了程序能够使用多大的内存空间；虚拟地址空间的大小则和具体的编译模式有关：
    1：32位编译模式：
        1：32位编译模式下，一个指针或者地址占用4个字节的内存，共有32位，理论上能够访问的虚拟内存空间大小为2的32次方，即0X100000000 Bytes，即4GB；有效的虚拟地址范围是0~0XFFFFFFFF;
        2：在32位编译模式下，无论实际的物理内存由多大，能够使用的虚拟地址空间范围只有0~0XFFFFFFFF，一个程序能够使用的最大内存空间只有4GB，和实际的物理内存大小无关；
        3：如果应用程序实际使用的内存超过4GB，那么操作系统会将这4GB的内存中暂时不用的数据先写入到磁盘，腾出内存空间给程序使用；
    2：64位编译模式：
        1：64位编译模式下，一个指针或者地址占用8个字节的内存，共有64位，理论上能够访问的虚拟内存空间大小为2的64次方；但是该值是一个相当大的数字，实际中的物理内存按照现有的技术不可能达到这么大，CPU的寻址能力也没有这么大，应用程序对于内存空间的需求同样也很少能够有这么大，因此实现64位长的虚拟地址只会增加系统的复杂度和地址转换的成本，并不会带来很可观的性能提升；
        2：在实际的64位编译模式中，windows和linux都对虚拟地址进行了限制，仅使用虚拟地址的低48位，总得虚拟地址空间为2的48次方；即：256TB；即64位编译模式下，一个应用程序能够使用的虚拟地址空间最多只有256TB，但是实际中的内存大小很少有这么大，实际能够使用的内存取决于真实的内存大小;

5：C语言内存对齐：
    1：内存在系统中被分割为若干个1字节大小的存储单元，每一个存储单元都会有一个编号，这个编号称之为存储单元的地址或者内存地址；理论上CPU可以直接访问任意地址的存储单元，但实际上为了数据读取效率，会对读取方式做优化，并非任意一个存储单元都可以被CPU直接读取；
    2：CPU通过地址总线来在内存上定位数据，CPU一次能够处理多少字节的数据，就会命令地址总线读取多少字节的数据，充分利用地址总线对于数据的读取机会；
    3：对于32位的CPU，一次可以处理4个字节的数据，地址总线将会按照地址为4的倍数一次读取4个字节的数据，比如从地址0,4,8,12等来读取数据，一次读取4个字节；对于64位的CPU一次可以处理8个字节的数据，地址总线将会按照地址为8的倍数一次读取8个字节的数据，比如从地址0,8,16,24等来读取数据；
    4：地址总线一次能够读取的最大字节数称之为步长，尽量将数据放在一个步长之内，比如对于32位：将int类型的数据放在0~4内，即可一次读取完，如果该int类型的数据起始地址为3，那么地址总线就需要读取两次才能拿到完整的数据；因此将数据放在一个步长之内，避免跨步长存储，导致读取数据效率降低，这种存储方式称之为内存对齐；
    5：内存对齐经常使用在结构体中；虽然使用内存对齐有时候会增加对内存的占用，但是提升了数据的读取效率；
    6：内存对齐的长度由CPU决定，但具体的对齐方式由编译器实现，因此在64位平台上使用32位的方式编译程序，改程序仍然以4字节对齐；



