一：C语言基本特征：
    1：C语言属于静态类型编程语言，C源程序需要先编译链接成可执行文件，需要执行程序时再由操作系统执行该可执行文件；由于提前将源程序编译链接为更切近硬件的字节码组成的可执行文件，因此该可执行文件在执行时效率较高；
    2：C语言允许直接访问物理地址，允许直接对位、字节、内存地址进行操作，因此其执行效率非常高；
    3：C语言在编程方式上仅支持面向过程编程，不支持面向对象编程；

二：C语言标准：
    1：C89和C90标准：
        C89来源：ANSI在1989年批准通过了C语言语法规范以及C语言标准库，因此称之为C89标准或者ANSI C；
        C90来源：ISO在1990年采用ANSI批准通过的C语言语法规范及C标准库，因此称之为C90标准或者ISO C；
        C89标准和C90标准指的是同一个标准；该标准也是编译器支持度最高的标准；
    2：C99标准：
        C89/C90标准发布之后，C语言标准委员会又不断的改进C语言；并最终在1999年开发布了新的C语言标准，并称之为C99标准；
        C99标准引入了许多新的特性：内联函数、可变长度数组、灵活的数组成员、复合字面量、支持不定参数个数的宏定义，在数据类型上还引入了long long int以及复数类型等新特性；
        目前对C99标准的支持在GCC以及Clang都能达到90%以上，但是Visual Studio目前支持度并不是特别高；
    3：C11标准：
        C语言标准委员会在2011年发布了新的C语言标准，称之为C11标准；C11在C99的基础上又引入了字节对齐说明符，泛型机制，对多线程的支持、静态断言、原子操作以及对Unicode的支持等特性；


三：C语言执行流程：
    概述：
        由于C语言是静态类型语言，需要先编译链接成可执行文件；在执行时由操作系统执行该可执行文件；因此C语言的执行流程需要经过如下5个过程：
            1：编写C源程序；
            2：对C源程序预处理得到预处理文件；
            3：对预处理文件编译得到汇编文件；
            4：对汇编文件汇编得到目标文件；
            5：将目标文件链接得到可执行文件
    详细流程：
        1：编写源程序：
            C源程序即由C语言编写的C程序，一个C源程序可以有一个或者多个C源文件组成，每一个C源文件都以.c作为后缀；

        2：进行预处理，得到预处理文件：
            1：C源程序中会有#include包含头文件的代码以及宏的使用，将源程序中#include包含头文件的代码替换成头文件的真正内容，以及将代码中的宏替换为宏真正的值，这个过程称之为预处理；
            2：预处理命令(gcc编译器)：gcc -E ./test.c -o test.i
            3：预处理完成后得到预处理文件，预处理文件以.i作为后缀，仍然是C语言组成的文本文件，可以通过文本编辑器打开；但是预处理文件的大小会大于C源程序，原因在于#include代码全部被替换为头文件真正的内容；

        3：对预处理文件进行编译，得到汇编文件：
            1：此处的编译并非指将C预处理文件直接编译为二进制的目标文件，而是指将预处理文件转换为特定汇编代码组成的文本文件；
            2：编译命令(gcc编译器)：gcc -S ./test.c -o ./test.s
            3：编译完成之后得到汇编文件，汇编文件以.s作为后缀，是一个由特定汇编代码组成的文本文件，可以通过文本编辑器打开；

        4：对汇编文件进行汇编操作，得到C源程序文件的二进制目标文件：
            1：汇编的过程是将编译完成后的汇编文件转换成二进制的目标文件的过程；
            2：汇编命令：gcc -c ./test.s -o ./test.o
            3：汇编完成之后得到汇编文件，以.o作为后缀，是一个二进制的目标文件；

        5：对目标文件进行链接操作，得到最终的二进制可执行文件：
            1：一个可执行文件包括四个部分：启动代码，引用到的库函数代码，C源文件汇编得到的目标文件，组成C源程序的其他C源文件汇编得到的目标文件；上一步汇编完成之后只是得到了一个C当前源文件的目标文件，还缺少启动代码、引用到的库函数代码以及组成C源程序的其他C源文件的目标文件，因此还不能作为可执行文件运行起来；
            2：链接的过程即为将当前C源文件汇编得到的目标文件，启动代码，库函数代码和组成C源程序的其他C源文件的目标文件合并成为一个完整的可执行文件的过程；
            3：链接命令：gcc -o ./test.out ./test.o ./a.o ./b.o
            4：链接完成之后即可得到最终的可执行文件，在linux平台上以.out作为后缀，在windows平台上，以.exe作为后缀！由于linux平台对于文件后缀并无要求，因此.out可以省略；

        6：特别注意：
            1：链接过程中导入库函数代码时，仅仅只会导入C源程序使用到的库函数代码，并不会将整个库的所有代码导入；
            2：如果一个C源程序是由多个C源文件组成的，在链接时需要将多个C源文件的目标文件链接起来；

四：编译器：
    Linux上的常用的编译器为：gcc（最终可执行文件的后缀名为.out）
    windows上常用的编译器为：Cygwin（最终可执行文件的后缀名为.exe）

五：C语言基本语法规范：
    1：C源程序组成：
        1：一个C源程序可以由一个或者多个C源文件组成； 
        2：一个C源程序的每一个C源文件都以.c作为后缀；
        3：一个C源程序必须要有并且只能有一个主函数；这个主函数可以放在任意一个C源文件中；
        4：C程序执行时，从主函数开始执行，并从主函数结尾；

    2：C语言基本语法：
        1：以;作为语句结束符号；
        2：以{}作为代码块包裹符号；
        3：以//作为单行注释，以/* ... */作为多行注释；
        4：标识符命名规范：
            1：以数字，字母，下划线组成；
            2：不能以数字开头；
            3：不能和关键字冲突；
            4：严格区分大小写；
            5：避免使用_或者__开头；
            6：避免使用拼音和英语混合式命名！
        5：一个C源文件结构上由两部分组成：1：函数、2：函数外部的代码；并且除过定义和声明类语句(如：全局变量的声明，宏的定义，类型的定义，预处理语句，函数的声明语句等)可以在放在函数外面；其余具备运算或者逻辑处理能力的语句都必须放在函数内部！

六：主函数：
    1：一个C源程序必须要有，并且只能有一个主函数；
    2：主函数可以放在任意一个C源文件中；
    3：C程序执行时，从主函数开始执行，并从主函数结尾处结束执行；并将执行状态以整数的形式传递给操作系统；
    4：主函数的名称只能是main，不能自定义为其他名称；
    5：主函数的定义方式：
        标准定义方式：
            1：int main(void){/* ... */}
            2：int main(int argc,char *argv[]){/* ... */}
        非标准定义方式：
            3：int main(int argc,char *argv,char *envp){/* ... */}
    5：主函数的形参说明：
        1：按照标准方式定义，可以选择以第一种方式声明，即不接受任何参数，直接声明为void；
        2：按照标准方式定义，也可以选择以第二种方式声明，接收两个参数；其中：
            int argc表示以命令行执行该程序的可执行文件时传入参数的个数；
                如果没有传递任何参数时，其值为1，因为可执行文件本身的名称也算是一个参数；
                如果有传入参数时，其值为参数个数+1；
            char *argv[]：一个字符串数组，每一项都指向使用命令行执行该程序时传入的字符串参数；
                其中argv[0]表示可执行文件的名称；
                其余传入的参数可以通过argv[1]~argv[argc-1]获取；
        3：按照非标准形式定义时，会在第二种定义的方式上多一个envp参数，表示执行该可执行文件时的环境信息，若干个字符串，每一个字符串都以键值对的形式表示环境信息；该参数表示的唤醒信息也可以在程序中通过getenv()标准函数获取；
    6：主函数的执行结果：
        C源程序从主函数开始执行，也从主函数结尾处结束执行；在主函数执行结束后，会将执行状态以整数的形式传递给操作系统；
        1：返回值是0或者EXIT_SUCCESS，表示程序执行过程一切顺利；成功执行完成！
        2：返回值是任何其他非0值，尤其是EXIT_FAILURE，则表示程序执行时出现问题；并未成功完整执行；
        3：mian函数并非必须调用return显示的返回一个整数值，如果程序运行到main()的右' } '处，将会自动向执行环境返回状态值0，如果执行发生异常则将会自动向执行环境返回非0状态值；
        4：main()函数的结束等效于在主线程中调用标准库函数exit(),main()的返回值作为exit()的参数；

七：C语言常用的输出方式：
    1：输出单个字符:
        putchar()       如：putchar('c')

    2：输出字符串：
        puts()          如：puts("string")

    3：格式化输出任意数据：
        printf()        
        1：基本使用方式：printf("格式化字符串",var1,var2,var3)
        2：格式化字符串由：自定义字符、格式化字符组成；其中自定义字符将会原样输出，格式化字符会按照顺序格式化待输出变量的值，并将格式化之后的值填充在格式化字符的位置，和自定义字符组成最终的字符串输出；
        3：格式化字符组成：%[flag][width][.precision][type]
        4：flag：
            -：默认输出是右对齐，带上-之后则为左对齐；
            +：正数带上+号，负数带上-号；
            #：对于小数，强制输出小数点，对于八进制，十六进制，二进制，带上前缀；
            空格：用于数字：正数加空格，负数加负号；
        5：width：最小宽度限制，对于字符串，如果字符串字符个数不足如果不足将会使用空格补齐，如果超出之后将会自动失效；
        6：.precision：
            对于 int，.precision 表示最小输出宽度
            对于 float，.precision 表示输出精度。
            对于 str，.precision 表示最大输出宽度。
        7：type:指定需要将变量格式化成指定的数据类型：
            字符/字符串：
                        %c          //格式化成字符类型
                        %s          //格式化成字符串类型
            浮点数：
                        %f          //格式化成单精度(float)类型的小数形式
                        %lf         //格式化成双精度(double)类型的小数形式
                        %e          //格式化成单精度(float)类型的指数形式
                        %le         //格式化成双精度(double)类型的指数形式
                        %E          //格式化成单精度(float)类型的指数形式(以大E表示)
                        %lE         //格式化成双精度(double)类型的指数形式(以小e表示)
            十进制整数：
                        %d          //格式化成十进制、有符号、int类型整数
                        %hd         //格式化成十进制、有符号、short类型整数 
                        %ld         //格式化成十进制、有符号、long类型整数
                        %u          //格式化成十进制、无符号、int类型整数
                        %hu         //格式化成十进制、无符号、short类型整数 
                        %lu         //格式化成十进制、无符号、long类型整数
            八进制整数：
                        %o          //格式化成八进制、无符号、int类型整数
                        %lo         //格式化成八进制、无符号、long类型整数
                        %ho         //格式化成八进制、无符号、short类型整数
            十六进制整数：
                        %x          //格式化成十六进制、无符号、int类型整数
                        %lx         //格式化成十六进制、无符号、long类型整数
                        %hx         //格式化成十六进制、无符号、short类型整数

八：C语言变量声明：
    C语言中变量使用基本规范：
        1：C语言中变量使用之前必须先声明，后使用；
        2：声明变量时，必须指明变量的数据类型，变量名称，如有必要可以赋上初始值；
        3：变量声明时，即确定该变量的数据类型；
        4：在程序运行过程中，变量只能指向和其数据类型相同的数据，不能指向其他数据类型的数据；

    C语言中变量命名规范：
        1：C语言变量名必须遵守C语言标识符命名规范；
        2：C语言变量推荐采用小写+_分割式命名；如：var_name

    C语言中的全局变量和局部变量：
        全局变量：
            在函数外部声明的变量称之为全局变量；
            全局变量声明位置：
                必须在使用之前声明该全局变量
            全局变量初始值：
                如果全局变量在声明的同时赋予初值则全局变量的初值即为所赋的值；
                如果全局变量在声明的同时并未赋值，则初值为0；
                全局变量只能在函数外部声明以及初始化，在函数外部不能参与任何赋值、运算以及逻辑处理；
            全局变量分为普通全局变量和静态全局变量：
                普通全局变量：
                    即不含任何特殊含义的全局变量；
                声明方式如：  
                    int a=1;
                普通全局变量的生命周期：
                    普通全局变量的生命周期和当前程序的生命周期一致，程序开始时初始化该全局变量，程序运行结束之后释放该全局变量；
                普通全局变量的作用域：
                    普通全局变量的作用域是组成c源程序的所有源文件；即多个c源文件中出现同名普通全局变量会冲突
                    普通全局变量可以在别的文件中通过extern引用;引用方式：extern date_type var_name

            静态全局变量：即作用域只在当前文件的全局变量：
                声明方式：
                    static int a=1;
                静态全局变量的生命周期：
                    静态全局变量的生命周期和当前程序的生命周期一致，程序开始时初始化该全局变量，程序运行结束之后释放该全局变量；
                静态全局变量的作用域：
                    静态全局变量的作用域只在当前C源文件内部；不会和其他c源文件中的同名全局变量冲突！
                    静态全局变量 不 可以在别的C源文件中通过extern引用
        
        局部变量：
            在函数内部声明的变量称之为局部变量；
            局部变量的声明位置：
                    对于c89/c90规定，在任何执行语句之前，在块的开头声明所有局部变量；
                    对于c99和c++中则没有这个限制，局部变量声明可以放在首次调用之前的任意位置； 
            局部变量初始值：
                如果声明局部变量之后未赋值，只会为其分配指定大小的内存空间，初始值是未知的，具体和分配的内存空间之前的值是一样的；
            局部变量作用域：
                只能在当前函数中，变量声明之后的代码块中使用；
            局部变量分为自动局部变量和静态局部变量：
                自动局部变量 auto
                    1：声明方式如：int b=3; 等同于auto int b=3;
                    2：该变量只能在所声明的函数中使用；其他函数不能调用；
                    3：其生命周期和函数保持一致，函数被调用时即初始化该变量，函数执行完毕之后即释放该局部变量；
                    4：自动局部变量如果不赋初值，其初始值是不确定的；

                静态局部变量 static
                    1：声明方式：static int a=12;
                    2：该变量只能在所声明的函数中使用；其他函数不能调用；
                    3：其生命周期和程序运行的生命周期一致，该特征和自动局部变量不同；
                        1：函数首次调用时即初始化该静态局部变量，但是函数运行完毕并不会释放该静态局部变量；并且在首次调用之后再次调用时不再初始化，其值为上次运行完毕最后一次对该变量修改的值；
                    4：如果静态局部变量不赋初值，其初始值不确定；
                    
                在函数内部定义的变量、数组、结构体、共用体等都称为局部数据。在很多编译器下，局部数据的初始值都是随机的、无意义的、未知的，或者为其分配的内存空间上次使用之后残留下来的数据，而不是通常认为的“零”值。
九：运算规则：
    1：运算级别：
        赋值运算= < &&和|| < 关系运算 < 算术运算 < ! < ()
    
    2: ()运算符：
        优先级最高，表示优先计算()里面的运算表达式；
    
    3: 算术运算：
        运算符：+ - * / % ++ --
        使用范围：只能适用于数字
        运算方向：从左至右运算
        级别：仅次于逻辑运算中的' ! '
        备注： 
            对于除法：
                如果除数和被除数都是整数，那么得到的结果也是整数；
                如果除数和被除数有一个是小数，那么得到的结果也是小数；并且是double类型的小数；
            对于取余运算：
                C语言中的取余运算只能针对于整数进行，即%两边都必须是整数，否则编译器将会报错！
            对于自增自减运算：
                前自增在赋值时先运算后赋值；
                后自增在赋值时先赋值后运算；
    
    4：关系运算：
        运算符：< > <= >= == !=
        运算方向：从左至右
        级别：整体级别大于逻辑运算符的&&和||，小于算术运算符，但是同级别内< > <= >=的级别大于==和!=；

    5：逻辑运算：
        运算符：&& || ！
        运算方向：从左至右
        级别：&& 和 || 小于关系运算符，！小于()大于算术运算符
        备注：运算结果是一个Bool值
    
    6：赋值运算符：
        运算符：= += -= *= /= %= 
        方向：将右侧的值赋给左侧
        级别：级别最低；

    7：位运算：直接对二进制位操作的方式
        c语言包括6种位运算：& | ^ ~ << >>
        &：按照二进制位求交运算
        |：按照二进制位求或运算
        ^：按照二进制位求异或运算
        ~：按照二进制位取反
        <<:按照二进制位全部左移，高位丢弃，低位补0；
            （如果数据较小，被丢弃的高位不包含 1，那么左移 n 位相当于乘以 2 的 n 次方。）
        >>：按照二进制位全部右移，低位丢弃，高位补0或者1；最高位是0就补0，最高位是1就补1；
            （如果被丢弃的低位不包含 1，那么右移 n 位相当于除以 2 的 n 次方（但被移除的位中经常会包含 1） 
            
    8：几种操作符号的优先级： 
        1：定义中被括号( )括起来的那部分，优先级最高；
        2：后缀操作符：括号( )表示这是一个函数，方括号[ ]表示这是一个数组，优先级次之；
        3：前缀操作符：星号*表示“指向xxx的指针”，&取地址符表示取某个变量的地址，优先级低于后缀操作符；

十：流程控制：
    1：条件：
        1：if..else条件语句：
            if(表达式)
            {

            }
            --------------------------
            if(表达式)
            {

            }else if(表达式)
            {

            }else{

            }
            --------------------------
            if(表达式)
            {

            }else{

            }
        2:switch条件语句：
            switch(var){
                case 1:
                    code..
                    break;
                case 2:
                    code..
                    break;
                default:
                    code...
            }
            备注： 
                1：switch中只能是整数，不能是浮点数或者其余数据类型；
                2：case只能是整数，不能是浮点数或者其余数据类型
                3：多个分支有共同处理方式，则多个分支可以放在一起，只在最后一个分支结束时使用break语句；
                4：default不是必须的；当所有的case都无法匹配时，将会走进default;
                
        3：? :   三目运算符；

    3：循环：
        for(int i=0;i<n;i++)
        {

        }
        --------------------------
        while(表达式)
        {

        }
        --------------------------
        do
        {

        }while(表达式);(;一定要有)

    4：跳出循环：
        1：break;结束当前循环；
        2：continue;结束当前循环，并开始新的循环！

十一数据类型：
    基本数据类型：
        1：整数类型：
            short int                     2字节(16位)                -32768到32767
            (short)                 
            unsigned short int            2字节(16位)                0~65535
            (unsigned short) 

            int                           2/4字节(16位/32位)         -32768到32767或者-2e32到2e32-1       
            unsigned int                  2/4字节(16位/32位)         0~65535或者0~2e33-1
            (unsigned)            (具体占用几个字节和平台以及编译器有关)

            long int                      8字节(64位)               -2e64到2e64-1
            (long)
            unsigned long int             8字节(64位)               0~2e65-1
            (unsigned long)

            long long int                 8字节(64位)               -2e64到2e64-1
            (long long)
            unsigned long long int        8字节                     0~2e65-1
            (unsigned long long)

            修饰类型：
                signed      有符号类型，最高位是符号位，不能存储数值；
                            该数据类型既可以存储正数也可以存储负数，数值区间在负数的最小值和正数的最大值之间；
                            是默认类型，无需显示的声明；
                            
                unsigned    无符号类型，最高位可以用来存储数值；
                            该数据类型只能存储正数，不能存储负数，数值区间在0到正数最大值之间，使用unsigned修饰数据类型可以表示更大的正数区间；同样大小位数的存储空间可以存储更多的正数；
                            不是默认类型，使用时必须显示的声明；

            数据溢出：
                向上溢出
                    数据向上溢出时，将会从数据类型的最小值开始从新计数，不同的是：
                        有符号类型溢出之后，将直接从负值最小值开始从新计数(向上递增)；
                        无符号类型溢出之后，将直接从0开始从新计数(向上递增)；
                向下溢出：
                    无论有符号还是无符号，均是从正值最大值从新计数(向下递减)；不同的是有符号类型和无符号类型的正值最大值不同！
            注意：
                所有的整数类型表示的数值范围都和具体的平台以及编译器实现有关，C语言规范并未作出明确要求；上述范围表示linux平台GCC编译器下的数值范围；

        2：浮点数：
            float                       4字节                 6位小数（精确度）、单精度
            double                      8字节                 15位小数（精确度）、双精度
            long double                 16字节                19位小数（精确度）、双精度
            备注：
                1：c语言中浮点数无法精确表示一个小数值，只能近似的表示该小数；
                2：浮点数在表示形式上可以使用小数形式表达，也可使用指数形式表达；
                3：在存储上，浮点数的整数部分和小数部分是分开存储的；
                4：对于算数运算，浮点数之间运算时损失的精度会更多；原因在于在任何区间内都存在无穷多个实数，浮点数不能表示区间内所有的值，只是按照精度逼近该小数；
        
        3：字符类型：
            1：C语言基本数据类型中没有字符串类型，只有字符类型；
            2：C语言中以''包裹的单个字符称为字符类型，以""包裹的单个字符或者多个字符称之为字符串类型；
            3：字符类型标识：char;
            4：在声明一个字符时使用char来声明，但是字符实际保存时则保存的是字符对应的编码值(ASCII)；
            5：char的大小是一个字节，标识范围在-128~127之间；unsigned char的表示范围在0~255之间；
            6：宽窄字符：
                1：以char声明的，以''包裹的称之为窄字符，由窄字符组成的字符串称之为窄字符串；
                2：窄字符以ASCII编码存储；
                3：由于在windows平台中文字符采用utf-16存储，即使用2个字节存储一个中文字符，但是在unix平台采用utf-32存储，即使用4个字节存储一个中文字符；由于中文字符在不同平台不同编译器的长度表示不一致，c标准推出了wchar_t类型，wchar_t的类型的长度由编译器决定！wchar_t类型位于<wchar.h>头文件中！
                4：使用wchar_t类型表示的字符称之为宽字符，由宽字符表示的字符串称之为宽字符串；
                5：使用wchar_t这种宽字符需要在字符前加L；如：wchar_t d = L'国';  //中文汉字 
            7：宽字符的打印：
            putwchar():只能输出宽单个字符，且要使用setlocale(LC_ALL,"zh_CN");来设置本地化
            wprintf():  用于输出宽字符串
                        宽字符标识：%ls;
                        用法：和printf完全一样
            8：常用的转义字符：
                1：转义字符以\或者\x开头，以\开头表示后跟八进制形式的编码值，以\x开头表示后跟十六进制编码值，对于转义字符来说，只能使用八进制或者十六进制；
                2：转义字符的初衷是用于ASCII编码，表示一些非打印字符因此取值范围有限：
                    八进制形式的转义字符最多后跟三个数字，即\ddd,最大取值\177;
                    十六进制形式的转义字符最多后跟两个数字，即\xdd，最大取值\7f
                    超出范围的转义字符是未定义的，如果是用超出范围的转义字符，编译器要么报错，要么直接输出！
                3：对于ASCII编码，0~31范围内的字符为控制字符，只能用转义字符来表示，常见的转义字符如下：
                    \a 	响铃(BEL)     
                    \b 	退格(BS)  
                    \f 	换页(FF)  
                    \n 	换行(LF)  
                    \r 	回车(CR)
                    \t 	水平制表(HT)     一般相当于四个空格，或者 tab 键的功能    
                    \v 	垂直制表(VT)    
                    \' 	单引号 
                    \" 	双引号 
                    \\ 	反斜杠 

        4：布尔类型：
            C99标准中添加了_Bool类型，用于表示布尔值；即：true和false
            _Bool大小仅为一位，存储0/1；0表示false,1表示true；
            C99标准中能够自动将其余数据类型转换为布尔类型的值；
        
        5：NULL类型：
            NULL本质上不是一种数据类型，而是一个宏,而且宏的值为一个指针，因此NULL的本质是一个指针；
            其原型为：#define NULL ((void *)0)
            对NULL的理解：NULL是一个指针，其值为0，但是该0和数值0并不相同；NULL表示的是一个存储单元的地址，只是该存储单元的地址值是0，并且该存储单元中存储的数据类型未知；
            特别注意：C语言并未规定NULL的指向，只是大部分标准库约定俗成将NULL指向了地址为0的存储单元；
        
        6：基本数据类型之间的转换：
            1：自动类型转换：
                自动类型转换是由编译器根据计算需求，自动将数据类型进行转换的一种方式；
                自动类型转换发生在两种情况下：
                    1：赋值时：如果类型转换合法，将会把右侧的变量转换为左侧变量的数据类型，然后赋值给左侧变量，右侧的数据类型不会被改变！(将高精度值赋给低精度值将会发生精度损失)
                    2：运算中：在运算时，编译器会将所有的数据的类型转换为同一种数据类型，然后再进行计算！
                        转换方向：
                            char/short->int->long
                                             ->float->double
                              转换方向为数据长度增加方向(高精度方向)进行;
                       所有的浮点运算都是以双精度进行的，即使运算中只有float类型，也将全部转换为double进行运算；
                       需要注意的是存储运算结果时数值的溢出！
            2：手动类型转换：
                强制类型转换方式：(目标数据类型)待转换变量  
            备注：
               1：无论是强制类型转换还是自动类型转换，转换改变的仅仅是结果，源数据的类型并不会改变！
               2：有些类型能够自动转换也能够强制转换，有些类型则只能强制转换不能自动转换！
               3：数据类型转换要合适，不能在不相干的数据类型之间随意转换，编译器将会报错！
            
    复杂数据类型：
        指针：
            1：指针：
                概念上理解：指针只是一个概念，一个不存在的虚拟概念,像一个箭头，指向某个存储单元；
                程序上理解：指针的具体体现就是指针变量，指针变量就是一个普通的变量，该变量的值是某个存储单元的地址；通过该指针变量的值即可找到对应地址的存储单元，进而能够访问到该存储单元中的数据；

            2：内存地址：
                1：数据必须先要加载至内存中，才能够被CPU获取并处理；
                2：计算机的内存在系统中会被分割为若干个1字节大小的存储单元，每一个存储单元都会有一个编号，代表该存储单元，称之为存储单元的地址或者内存地址；通过这个地址就可以找到存储单元，并访问其中的数据； 
                3：内存中存储单元的地址是从0开始的，以十六进制表示；
                4：理论上：一个指针变量可以指向计算机中的任何一块内存，不管该内存有没有被分配，也不管该内存有没有使用权限，只要把地址给它，它就可以指向;
            
            3：指针和数据：
                指针是一个虚拟的概念，表示对存储单元的指向，反映在程序上则为指针变量，其值为某个存储单元的地址；
                数据则是一个明确的值，存储在存储单元中；
            
            4：指针变量和普通变量：
                指针变量和普通的变量一样都是变量；区别在于：
                    1：指针变量的值表示某一个存储单元的地址；普通变量的值表示某一个存储单元中的内容；
                    2：指针变量的数据类型固定为unsigned int类型的16进制整数；普通变量的数据类型根据声明而定；
                特别注意：虽然指针变量存储的是unsigned int类型的整数，但是不可以将指针变量和存储unsigned int类型的普通变量进行运算！其意义完全不一样！

                **关于指针变量和普通变量声明的思考**：
                    
                    1：相同点在于：
                        无论是指针变量还是普通变量，表示的就是某个内存块中的内容；而内存块则由一个或者多个存储单元组成(比如声明一个short类型的变量，系统就会分配一个内存块，占用2字节大小，变量的值就是该2个字节中的内容)；
                    2：不同点在于：
                        声明普通变量时：系统将会按照变量的数据类型在当前平台占用的字节个数来分配对应个数的存储单元来存储变量中的值；
                        声明指针变量时：系统将会按照unsigned int类型在当前平台占用的字节数来分配存储单元以存储指针变量的值；

                    3：和普通变量一样的是，指针的变量的值也是存储在多个存储单元组成的内存块中，存储指针变量的值的内存块也是有地址的，因此同样也可以被其他指针指向；
            
            5：指针变量的声明：
                声明方式1：数据类型 *变量名
                声明方式2：数据类型 * 变量名
                备注： 
                    1：类型名称是指该指针指向的存储单元中存储的数据的数据类型；一旦声明完成之后，该指针指向的存储单元将只能存储声明的数据类型的数据；
                    2：*表明该变量是一个指针变量，该变量的值表示的是某一个存储单元的地址，而不再是某一个数据；*在指针变量声明时，可以有空格也可以紧贴变量名；
                    3：变量的命名规范和普通的变量命名规范一样；
            
            6：指针变量允许的运算；
                1：&:该符号是取地址符；可以通过&符号获取变量所表示的值在内存中的地址；对普通变量和指针变量都可以使用
                2：*:该符号是取值符，可以通过*获取指针变量指向的存储单元中所存储的值；
                3：设置存储单元中的内容：*指针变量 = 值；即可将值赋值给指针变量指向的存储单元；
                4：赋值：指针变量的值可以赋值给另一个指针变量(1：赋值双方必须都是指针变量；2：两个指针变量必须是相同的数据类型)
                5：加减运算：指针变量允许加上或者减去一个整数；
                6：自增/自减运算：指针变量允许进行自增自减运算；
                7：指针变量加减整数或者自增自减运算说明：
                    1：普通变量加减某一个整数是指给存储单元中存储的数据本身加/减去n，不会引起数据在内存中存储地址的改变；
                    2：指针变量加减某个整数m或者自增自减运算:
                        微观上看：指针变量加/减某个整数m，是指将指针变量的指向跳过n*m个存储单元，n是指当前指针变量数据类型在当前平台所占字节个数；
                        宏观上看：指针变量的加减运算改变的是当前指针对存储单元的指向；
                    3：不允许对指针变量做除过加减/自增自减以外的任何其他算术运算；
                    4：普通的指针变量做自增自减或者加减运算并无任何实际意义；指针的指向会改变，但是指向新的存储单元中的数据则是不确定的；
                    5：对于数组或者字符串,由于其占用的是一段连续的存储单元，因此指针变量的加减/自增自减改变的是指针指向的元素位置，其值是可以预料的，通过对指针位置的改变可以获取到相邻的元素值，是有意义的；
            7：空指针：
                1：在函数中声明一个指针变量，如果不为该指针变量进行初始化，该指针变量的值就是不确定的，因此该指针变量指向哪一个存储单元也是未知的，大多数情况下是未分配或者没有读写权限的；如果对于这种指针变量不做处理，对程序的健壮性有影响；
                2：如果一个局部指针变量未被初始化的时候，推荐赋值为NULL，即将该指针设置为空指针；
                3：空指针的意思为：将一个指针变量的值设置为NULL；即该指针指向地址为0的存储单元，但是该存储单元中存储的数据类型以及数据内容是未知的！
            
            8：二级指针：
                1：指针变量的值也是存储在多个存储单元组成的内存块中，存储指针变量值的存储单元也是有地址的，指向存储指针变量值的存储单元的指针称之为二级指针；
                2：从宏观角度来理解：二级指针即为指向另一个指针的指针；
                  从微观角度来理解：二级指针变量仍然只是一个普通的指针变量，其值仍然代表的是某一个存储单元的地址；只是其指向的存储单元中的值代表的是另一个存储单元的地址；
                3：二级指针变量仍然只是一个普通的指针变量，数据类型仍然为unsigned int，其值仍然代表的是某一个存储单元的地址；
                4：二级指针需要使用**来声明，同理三级指针需要使用***来声明；
                4：对二级指针进行*取值运算之后得到的结果是另一个存储单元的地址，对得到的存储单元的地址再次进行*取值运算之后将会得到该存储单元指向的内存块中的值；因此如果是取值，需要使用**来对二级变量取值，同理三级指针需要使用***;

            9：野指针：
                1：所谓野指针，是指没有明确合法指向的指针，称之为野指针；
                2：野指针随机指向一块空间，该空间中存储的可能是其他程序的数据，甚至是系统数据，其指向完全不确定，因此不能对野指针所指向的空间进行存取操作，否则轻则引起程序崩溃，重则可能导致整个系统崩溃！
        
        数组：
            1：数组：
                数据的有序集合称之为数组，数组中的每一个值称为数组的元素，数组中值的个数称之为数组的长度，数组的元素可以通过元素的序号获取得到；

            2：数组的声明：
                1：数组在使用之前需要先声明后使用；
                2：数组的声明方式：数据类型 数组名[数组长度]；数据类型代表数组元素的数据类型；
                3：如果在函数内部声明数组，声明完成之后如果未初始化，那么数组的值是不确定的；
                4：C语言中的数组称之为静态数组，一旦声明完成之后其元素个数不能超过数组长度，否则将会发生溢出；
                5：C语言中的数组在声明完成之后就已经确定存储的数据的数据类型，因此必须存入和声明时数据类型相同的数据，不能存储数据类型不一致的数据；

            3：数组的赋值：
                1：数组可以在声明的同时完成赋值：
                    1：完全赋值：即按照所声明的数组长度，填入相同个数的值；
                                如：int arr[3] = {1,2,3}
                            备注：完全赋值时数组可以不用显式指定长度；
                                如：int arr[] = {1,2,3}

                    2：不完全赋值：赋值的个数少于数组声明时指定的个数；
                                如：int arr[3] = {1}
                            备注：不完全赋值时，数组未赋值的部分也会按照基本规则进行初始化：
                                1：如果数组类型为：int,short,long,将直接赋值为整数0；
                                2：如果数组类型为：char,将赋值为\0；
                                3：如果数组类型为：float或者double，则将会赋值为0.0；
                2：数组在声明完成之后也可以进行赋值：
                    数组在声明完成之后只能通过下标一个一个进行赋值，不能再使用{}整体进行赋值;

            4：数组使用时的注意事项：
                1：数组是占用一段连续的存储空间来存储数组元素的；
                2：数组元素在赋值的时候只能赋值声明的数据类型的值，不能赋值其他数据类型的值；
                3：数组中元素的个数不能超过数组声明时指定的长度，否则将会出现溢出；
                4：C语言中数组是静态数组，即长度一旦声明好之后将不能再改变，插入数据的个数不能超过长度，也不能随意删除数据；
                5：固定长度的数组是在编译期间分配内存的；

            5：二维数组：
                二维数组的声明：
                    数据类型 数组名[一维长度][二维长度];
                二维数组的本质：
                    二维数组本质上类似于一个矩阵：一维长度指的是矩阵的行数，二维长度指的是矩阵的列数；
                二维数组的存储：
                    二维数组在概念上是二维状态存在，但是在内存中则是按照一维顺序排列的；
                二维数组的赋值：
                    1：分段赋值：
                        1：完全赋值：每一行都完全赋值；
                        2：部分赋值：默认从左向右赋值，其余则按照数据类型填充；
                    2：连续赋值：
                        1：完全赋值：从左向右按行赋值；此时可不必给出一维长度；
                        2：部分赋值：从左向右按行赋值；其余则按照数据类型填充；
            
            6：数组与指针：
                1：数组一旦声明完成之后将占用的是一段连续的存储单元，占用存储单元的个数=数组长度*数组元素类型在当前平台占用的字节个数；数组的元素按顺序存储在这段连续的存储单元中,数组元素的插入，获取时间复杂度均为O(1)；

                2：数组指针：
                    1：指向数组中某一个元素的指针称之为某个数组的数组指针，数组指针和普通的指针并无区别，仅仅只是在意义上数组指针代表的是某个数组中的某一个元素的地址而已；
                    2：数组指针指向数组中的某一个元素，也仅仅只能够代表其所指向的数组元素，并不能够代表整个数组；即便数组指针指向的是数组的第一个元素，也只能代表数组的第一个元素，无法代表整个数组；
                    3：由于数组占用的是一段连续的存储单元，因此数组指针的加减和自曾自减即指向上一个或者下一个数组元素；因此通过数组指针也可以获取数组元素；

                3：数组名：
                    1：数组名仍然是一个变量，代表的是某一个数组；既可以看做整个数组的首地址，也可以看做整个数组；
                    2：C语言中在&运算符、sizeof运算符、数组声明时数组名代表整个数组，除上述三种情况以外，数组名均代表数组的首地址，即数组的第一个元素，此时本质上数组名是一个指针，保存的是数组第一个元素的地址；
                    3：如果数组名代表的是数组的首地址，则和指向数组第一个元素的指针变量等价，否则和数组指针不等价！

            7：数组的基本操作：
                1：获取数组长度：
                    int len = sizeof(数组名)/sizeof(数组元素类型)
                    注意：
                        1：此种方式计算数组长度时，数组名必须代表的是整个数组，不能是指向第一个元素的数组指针；
                        2：如果函数要求传入数组类型的数据，此时如果传入数组名则仅仅代表的是数组的首地址，并不能代表整个数组，根据传入的数组名也无法使用sizeof来计算数组的长度，数组长度需要单独传入；
                2：数组的取值：
                    1：通过数组名访问：数组名[下标]
                    2：通过指针的方式访问：*(数组名+下标)
                    3：通过数组指针访问：*(数组指针+n)

                3：数组的赋值：
                    1：通过数组名赋值：数组名[下标] = 值
                    2：通过指针的方式赋值：*(数组名+下标) = 值
                    3：通过数组指针赋值：*(数组指针+n) = 值  

            8：指针数组：
                1：指针数组是指数组的每一项都代表一个指针；本质上和普通的数组并无区别！
                2：指针数组的声明方式：
                    1：数据类型名 *数组名[数组长度]
                    2：数据类型名 *(数组名[数组长度])
                3：数组指针指的是指向数组中某一个元素的指针；指针数组是一个数组，只是数组的每一项都是一个指针！
                4：对于指针数组声明方式的理解：
                    指针数组的声明方式为：数据类型名 *数组名[数组长度]；
                    1：根据C语言中的运算优先级规则来看，[]后缀运算符的优先级大于前缀运算符*，所以，数组名代表的是一个元素个数为指定长度的数组；
                    2：再按照运算优先级来看，前缀运算符则修饰整个数组(即数组中的每一个元素)，前缀运算符为数据类型名 *，因此数组中的每一个元素都为指定数据类型的指针；
                    3：由于后缀运算符[]的优先级大于前缀运算符*；因此()可以有也可以没有；
                5：指针数组名的理解：和普通数组一样，在声明、&、sizeof()运算符中代表的是整个数组，即代表数组中的每一个元素；除此之外，指针数组名代表指向第一个数组元素的地址，由于第一个元素也是指针，所以指针数组名此时代表的则是二级指针；
            
            9：二维数组指针与二维数组：
                1：二维数组在概念上是二维的，但是在存储上是一维线性连续存储的；
                2：相对于一维数组，指向一维数组元素的指针，称之为数组指针；那么同样，指向二维数组中的某一维的指针也被称之为数组指针，但是其代表某个一维数组的首地址，而非具体的数组元素；本质上是一个二级指针；
                2：二维数组指针的方式声明：数据类型 (*数组名)[n]; 如int (*p)[2]
                3：关于二维数组和指针的理解：
                声明一个数组如：int a[3][2] = {{1,2},{3,4},{5,6}}
                    那么a即等价于a[0]，a[0]本质上则是指向数组{1,2};
                对于使用指针声明的方式而言：int (*p)[2]:p即为二维数组指针；指向二维数组中的某一维；
                4：对于二维数组名而言，在数组声明，sizeof(),&取地址运算符以外，其代表的是指向二维数组中第一维的指针，此时二维数组名是一个二级指针！

        字符串：
            1：C语言中并没有专门存储字符串的基本数据类型，但并表示C语言不支持字符串！在C语言中使用数组来存储字符串、使用字符数组或者""来声明字符串！
            2：字符串的声明及初始化方式：
                声明方式1：char str1[2];   赋值：str1[0]='a';str1[1]='b';

                声明方式2：char str2[2] = {'a','b'};
                声明方式3：char str3[]  = {'a','b'};

                声明方式4：char str4[2] = {"ab"};
                声明方式5：char str5[]  = {"ab"};

                ---------以上方式声明的字符串是在栈区或者全局数据区，具备可读可写权限---------

                声明方式6：char *str6   = "ab";
                声明方式7：char *str7   = {"ab"};
                ---------以上方式声明的字符串是在常量区，只有可读权限，一旦初始化完成，将无法再修改--------
                **备注：
                    1：无论是以数组方式声明还是以指针的方式声明，无论以字符的方式初始化还是以字符串的方式初始化：本质上都是通过字符数组的方式来存储字符串！因此对于字符串的处理，可以完全使用处理字符数组的方式处理！
                    2：由于数组本身也是可以使用数组指针来进行数组元素的处理，所以，字符串同样可以使用指针进行处理！

            3：获取字符串中的字符：
                字符串本质上是通过字符数组进行存储的，因此无论使用哪种声明方式都可以通过一下方式获取字符串中的字符：
                    1：数组的方式获取字符串中的字符：str1[0]; 或者：str6[n];
                    2：指针的方式获取字符串中的字符：*str1;   或者：*(str1+n);

            4：字符串的存储位置：
                1：通过字符数组的方式声明的字符串，其存储位置是在栈区或者全局数据区；应用程序具备读取和写入的权限！因此可以对字符串本身进行修改！同时也可以修改字符串变量的指向；

                2：通过字符指针的方式声明的字符串，其存储位置是在常量区；应用程序只有读权限，没有写入权限！不能够对字符串本身进行修改，但是可以修改字符串的指向！

            5：字符串的长度：
                1：字符串如果通过字符数组的方式声明，并以单个字符进行初始化，那么字符串的长度即为数组中的元素个数：
                    1：使用sizeof(字符数组名) 无论字符串以何种方式声明：
                            如果是以字符数组的方式初始化：本质上计算得到的长度是字符数组的声明长度，并非字符串实际长度！
                            如果是以字符串的方式初始化:计算得带的长度是字符个数+1；(原因在于系统会自动在字符串后面加上'\0');
                    2：使用strlen(字符数组名) 计算得到的长度则是字符串的实际长度！

                3：注意'x'和"x"不同，'x'代表字符，"x"代表单字符字符串；
                4：string.h头文件声明了对字符串的所有操作；包括最常用的strlen();

            6：对于字符串数组的理解：
                1：字符串数组声明：char *str[]={"string1","strign2"}中：
                    第一问：为何需要声明成char *str[] 这种格式：
                        1：从指针方面理解：虽然在数组内部初始化的时候填写了完整的字符串内容，但是系统在存储的时候存储的是指向字符串本身的指针；因此字符串数组本质上是一个指针数组；等价于：
                            char * str_item1 = "string1";
                            char * str_item2 = "string2";
                            char *str[] = {srt_item1,str_item2};
                        所以：char *str[]代表声明一个字符指针数组；

                        2：从字符数组方面理解：字符串数组中的每一个字符串本质上都是一个字符数组，因此字符串数组本质上也可以看做是一个二维字符数组；等价于：
                            char str_item1[] = {'s','t','r','i','n','g','1'}
                            char str_item2[] = {'s','t','r','i','n','g','2'}
                            char *str[] = {str_item1,str_item2};
                        所以：char *str[] 代表声明一个二维字符数组；
                        
                    第二问：字符串数组的名称代表什么意思：
                        1：从数组方面理解：字符串数组本质上是一个二维字符数组，因此字符串数组名等价于二维数组名；
                        2：从指针方面理解：字符串数组本质上是一个指针数组，字符串数组名指向第一个指针，因此字符串数组名等价于二级指针；
                
        结构体：
            结构体：结构体是一种数据的集合，可以用来存放一组数据；

            结构体与数组：
                结构体：
                    1：既可以存储同种数据类型的数据，也可以存储不同数据类型的数据！
                    2：结构体中的数据是通过数据名称来操作的；
                数组：
                    1：只能存储声明时所声明的数据类型，不能混合存储不同数据类型的数据；
                    2：数组中的数据只有索引，没有名称；可以通过索引来操作数组中的数据；
            
            结构体的声明：
                声明：struct 结构体名称{
                    数据类型 数据名称1;
                    数据类型 数据名称2;
                            .
                            .
                };
                示例：struct Stu{
                    short age;
                    int   num;
                    char *name;
                };
                备注：
                    1：struct 关键字声明后面的代码块是一个结构体；
                    2：Stu即为结构体的名称；其命名必须符合C语言标识符命名规范；
                    3：结构体本质是一种数据集合的模板，声明了该模板中所包含的数据成员，以及每一个数据成员的类型，名称；
                    4：由于结构体本质上只是一种数据集合的模板，只是一种代码约束和规范，因此结构体名本质上只是该数据集合模板的一个标识，并不是变量，因此并不占有存储空间！
                    5：结构体可以嵌套其他结构体；
            结构体变量：
                1：声明一个结构体类型的变量，称之为结构体变量；
                2：结构体变量的声明方式：
                    struct 结构体名 结构体变量名1，结构体变量名2；
                3：对于结构体变量的理解：
                    1：声明结构体变量时，系统将会按照预先声明的结构体成员数量及类型，分配一段连续的存储单元！结构体变量即指向这一段连续存储单元的首地址！
                    2：每声明一个结构体变量，系统即分配一段这样的内存块；
                    3：宏观上来看，结构体更像是指导系统如何为变量分配内存块；像是一种数据类型，但是本质上不是数据类型！
            结构体指针：
                1：结构体指针指的是某个结构体变量在内存中的地址；
                2：声明方式：struct 结构体名 *pointer;
                3：一些注意事项：
                    1：对于数组而言，数组名在sizeof,&取地址运算符，以及数组声明时代表的是整个数组，除此之外只能代表数组的首地址；
                    2：结构体变量名，无论何时，都代表结构体所有成员！
                    3：数组指针指的是指向数组中某一个元素的指针，但是结构体指针代表的是整个结构体成员！
                    特别注意：结构体指针指的是指向某个结构体变量的指针，并非结构体本身的指针，结构体本身只是一种数据集合的模板，并不占内存，因此不存在指向结构体本身的指针！
            结构体数组：
                仍然是一个数组，只不过数组的每一项都是一个结构体(指针)！
            
            结构体操作：
                取值:1：结构体变量名.结构体成员名
                     2：结构体指针变量名->结构体成员名
                     3：*(结构体指针变量名).结构体成员名

                赋值:1：结构体变量名.结构体成员名 = 值
                     2：结构体指针变量名->结构体成员名 = 值
                     3：(*结构体指针变量名).结构体成员名 = 值
            
            结构体占用内存空间的大小：
                1：结构体中每一个成员在内存中的存储是连续且有序的；
                2：结构体占用内存空间的大小有可能是结构体中每个成员的数据类型在当前平台占用内存大小的总和；但是由于内存对齐的原因也有可能大于总和！
                3：内存对齐：
                    1：计算机内存被分割为1字节大小的多个存储单元，理论上cpu可以访问任意编号的存储单元，无论该存储单元是否有权限！
                    2：实际上cpu通过地址总线来访问内存，一次能处理几个字节的数据，就命令地址总线读取几个字节的数据(32位平台的cpu一次可以处理4个字节的数据，64位平台的cpu一次可以处理8个字节的数据)；每次可以读取的字节个数称之为步长！
                    3：将一个数据尽量放在一个步长之内，避免跨步长存储，CPU即可一次读取到需要的数据，可以提高数据读取效率，这称为内存对齐；
                    4：在32位平台默认以4字节对齐，在64位平台默认以8字节对齐；
                    5：c语言编译器为了提高数据的存取效率会自动根据平台进行内存对齐；因此会出现结构体存在存储缝隙的现象；出于该原因，结构体的大小是有可能大于结构体成员数据类型在该平台占用字节的总和！
                    6：示例：
                        struct tmp {
                            char name[8];
                            int length;
                        };
                        该结构体在win32位平台下，sizeof的值是12；
                        struct tmp {
                            char name[10];
                            int length;
                        };
                        该结构体在win32位平台下，sizeof的值是16；多出的两个字节是由于32位平台内存以4字节对齐，前10个字节刚好差两个字节成功成为4的倍数，实现4字节对齐，因此name数组和length之间就存在两个字节的缝隙；  
                    7：由于内存对齐的原因，结构体在声明时要特别注意不同数据类型成员之间的顺序！
        共用体:
            1：共用体：
                共用体在意义上和结构体一致，都是定义了一种数据集合模板；类似定义一种新的数据类型；
            2：共用体和结构体：
                相同点：
                    共用体和结构体都定义了一种新的数据类型，声明了一组数据集合模板；声明变量时，编译器将会按照定义的数据集合模板申请内存空间！
                不同点：
                    结构体：结构体中的各个成员各自拥有自己的内存空间，各个成员之间互相没有影响；
                    共用体：共用体中的各个成员共享同一段内存空间，并朝一个方向对齐；同一时刻只能存在一个成员的值；由于所有成员占用同一段内存空间，因此修改一个成员会影响其他所有成员；
            3：共用体声明：
                union 共用体名{
                    数据类型  成员名;
                    数据类型  成员名;
                         .
                         .
                }
            4：共用体占用内存空间大小：
                1：共用体中，由于各个成员共享同一段内存空间，因此一个共用体变量占用的内存大小是：共用体成员中占用内存空间最大的成员所占用的内存空间；如：
                    union data{
                        int    score;
                        char   name;
                        double id
                    };
                    union data a;
                    a变量是一个共用体类型的变量，该共用体中占用空间最大的是double类型的成员id;因此整个共用体占用的内存空间大小为8个字节；
                2：共用体使用了内存覆盖技术，同一时刻只能存在一个共用体成员：
                    即声明一个共用体变量，编译器将会为该共用体申请一段内存空间，这段内存空间的大小是共用体中占用空间最长的成员的长度，这段内存空间同一时刻只能允许设置一个成员的值，为共用体成员每次设置新值的时候都会从某一端开始设置值；因此如果对共用体中其他成员设置了值，那么未被设置值的成员会受影响。
            5：共用体的应用：
                共用体可以用在多个成员大小相近，业务类型相似，但又不可能同时存在的情况下；
            
        位域：
            1：有些情况下，存储数据并不需要一个或者多个完整的字节，只需要占用一个或者几个二进制位即可，C语言针对这种情况提供了位域这种数据结构；更加节省内存空间！
            2：位域并不是一个单独的数据结构，而是在声明结构体的时候只需要指明某个成员变量所占用的二进制位数，这就是位域！如：
                struct bs{
                    unsigned m;
                    unsigned n:4;
                    unsigned char ch:6;
                }
                说明：
                    1：:后面即限定二进制位数；
                    2：成员m没有设置二进制位数的限制，因此根据编译器将会根据类型来确定m所占用的内存空间(4个字节);
                    3：成员n和成员ch使用了 : 来限制所占用的二进制位数，因此编译器将不会再按照声明的类型来确定成员变量所占用的内存空间；而是:后面所设置的位数(n占用4个二进制位,ch占用6个二进制位)      
                    4：成员变量的数据类型限定了该成员的最大长度，:后面的数字不能超过这个长度！
                    5：C语言标准规定：ANSI中只有int、unsigned int、signed int可以支持位域，但是在编译器具体实现时都进行了扩展：额外支持了char、signed char、unsigned char以及enum类型
            3：位域的存储：
                C语言标准并未规定位域的存储方式，不同的编译器有不同的实现，但是都会尽量压缩存储空间；
                1：具体规则如下：
                    1:当相邻成员类型相同时，
                        1：如果他们的位宽之和小于类型的sizeof大小，那么后面的成员紧邻前一个成员存储，知直到不能容纳为止；
                        2：如果他们的位宽之和大于类型的sizeof之和，那么后面的成员将从新的存储单元开始存储，其偏移量为类型大小的整数倍！
                        3：特别注意：位域的sizeof值是内存对齐之后所占用内存大小的值(至少4/8字节或者为其整数倍)！
                    2:当相邻成员的类型不同时，不同的编译器有不同的实现方案，GCC会压缩存储，VC/VS不会！
                    3：特别注意：位域成员往往不占用完整的字节，因此使用&取地址运算符获取位域成员地址没有任何意义，因为位域成员是以位为单位的，而地址则是字节的编号，不是位的编号！

            4：无名位域：
                1：位域成员可以没有名称，只给出数据类型和所占用的位宽；
                    如：
                        struct bs{
                            int m: 12;
                            int  : 20;  //该位域成员不能使用
                            int n: 4;
                        };
                2：无名位域一般用来做填充或者调整成员位置；因为没有名称，无名位域不能使用；
                
十二：常量：
    1：在C语言中，常量是指一旦被声明并初始化完成之后，就不能再修改值得量；
    2：C语言中通过const来修饰一个变量，可以得到一个常量！
    3：const的使用方式：
        const 数据类型名称 变量名称 = 值;
    4：几种const使用方式的结果：
        1：const要求在声明变量时即初始化，否则将无法再赋值；
        2：const来修饰普通的变量，该变量本身的值将不能再被修改；
        3：const来修饰指针变量，一般有一下三种形式：
            1：const要求在声明变量时即初始化，否则将无法再赋值；
            2：const来修饰普通变量，则该变量将不能再重新赋值；使用方式：const type var_name = value;
            3：const来修饰指针变量，则有三种情况：
                情况1：const 修饰的是指针符号和变量名，那么指针变量所指向的内存空间中的值不能被修改；指针变量本身可以修改指向不同的内存空间！如：
                    const int *pointer;
                    int const *pointer;
                情况2：const 修饰的是变量名，不包括指针符号，那么指针变量本身不能修改，即指针变量不能再被修改指向其他内存空间：
                    int * const pointer;
                情况3：const 既修饰指针又修饰变量，则指针变量本身不能再被修改，即指针变量不能再被修改为指向其他内存空间，且指针变量指向的内存空间中的值也不能再改变！
                    int const * const pointer
            4：一般在函数的形式参数处，如果函数需要保证某个参数不会被函数内部修改，就可以使用const修饰；

十三：为数据类型定义别名：
    C语言中可以通过typedef oldname newname的方式来定义新的数据类型；
    1：为基本数据类型定义别名：
        如：声明：typedef int INTEGER;  那么INTEGER就代表int类型的数据
            使用：INTEGER 1;            等价于int i;
    2：为数组类型定义别名：
        如：声明：typedef char arrtype[20];  那么arrtype就等同于一个char类型长度为20的数组；
            使用：arrtype a1,a2;             等价于char a1[20],a2[20]
    3：为结构体定义别名：
        如：声明：typedef struct stu{
                    char  *name;
                    short age;
                 } STU;                     那么STU就代表stu结构体；
            使用：STU stu1;                  等价于struct stu stu1；
十四：函数：
    1：函数即声明的代码块，c代码文件中可以有任意多个函数；
    2：函数的声明：
        返回值类型/void function_name(int a,int b){
                code....
        }
        备注：  
            1：函数声明要注明返回值类型，没有返回值时要写void；
            2：函数名要遵守c语言标识符命名规范；推荐以小写加下划线方式命名；
            3：形参需要通过数据类型 变量的方式声明，多个形参使用,隔开；
            4：在函数体中使用return语句返回数据。
    3：形参：
        1：形参是声明函数在调用时必须传入的参数，要写在()中；多个形参以 ，分割；且形参要注明数据类型；
        2：形参不允许赋初值；
        3：形参和实参在数量上，顺序上，类型上必须严格一致；
        4：函数调用中参数传递是单向的，即：只能将实参的值赋值给形参，不能把形参的值赋给实参，因此，形参的值发生改变并不会影响实参的值；
        5：形参变量只有在函数调用时才会分配内存，调用结束后，立刻释放内存；形参在函数执行完成之后，将会销毁形参变量本身的值；如果形参变量的值是一个存储单元的地址，那么销毁指的是销毁该指针变量的值，而非销毁该指针变量指向存储单元中的内容；
        6：基于第5条，如果需要得到函数的返回值可以有两种做法：
            1：在函数中为全局变量赋值，函数的调用方直接从全局变量中获取函数的返回值；
            2：通过函数的形参接收返回值，即：传入一个地址，在函数中把需要返回的值写入该地址即可；
            (通过形参接收返回值时，传入的必须是实参变量的地址，不能是具体的变量，否则函数运行完毕将会销毁形参变量的值，外部将无法拿到该值；如果传入的是地址，那么虽然形参变量的值被销毁，但是形参变量指向的地址中内容并不会被销毁；该内容通过实参变量仍然可以拿到)
        6：对于函数需要传入数组，结构体，函数，字符串等复杂的数据类型时，推荐传入指针！

    4：函数的返回值：
        1：返回值使用return;即：return 表达式;
        2：一个函数可以有多个return语句，但是只会执行第一个；

    5：函数调用：
        1：函数调用：函数名(实参) 即可调用；如果函数有返回值则可以使用变量接收返回值；如果没有返回值则不要使用变量接收函数调用的结果；
        2：c语言的执行逻辑是从main函数开始执行，而且是依次从上往下逐条执行；原则上函数的定义要出现在函数的调用之前；否则将会报错；
        3：如果函数在定义之前需要使用则需要提前声明；

    6：函数的声明：
        1：声明格式：返回值类型 函数名 （类型 形参，类型 形参,...）;或者返回值类型 函数名 （类型,类型,...）;
        2：在函数调用之前有了函数的声明，函数实体将可以出现在任何地方，可以使其他文件，静态链接库，动态链接库；

    7：递归：
        1：函数中自己调用自己的过程称为递归；
        2：在函数中每递归一次，就等同于从新调用一次该函数；
        3：基于第二条，因此在递归中每递归一次，函数被调用一次，函数所使用到的局部变量都将被重新创建一次；并放在栈中！递归完成之后将会按照调用栈层层返回；
        4：基于第三条：递归的调用速度是低于循环的，而且占用额外的内存空间；并且递归的深度取决于内存的大小；
        5：尾递归：函数的递归放置在最后一行，即：函数调用完自身后，原函数即结束，这样的递归称之为尾递归；
        6：尾递归的优势：基于2~3条，函数的递归深度取决于内存的大小，如果递归深度过深将会超过内存限制而出错！如果是尾递归，函数每进行下一次新的调用，上一次的函数执行即结束，函数调用栈中永远只有一个函数，不会超过内存限制！

    8：函数指针：
        1：函数在程序运行时，代码是存储在内存中的，并占用一段连续的存储单元；函数名在表达式中有时也会被转换为存储函数代码的内存区域的首地址；
        2：可以定义一个指针变量，指向存储函数代码的内存块的地址，通过该指针变量即可找到函数的内容，进而调用函数；这样的指针称之为函数指针，指针变量称之为函数指针变量；
        3：函数指针的声明形式：
            returnType (*pointerName)(param list)
            备注：
                1：returnType指的是该函数的返回值类型；
                2：pointerName是函数指针变量的名称；*pointerName指明该变量是一个指针类型的；(* pointerName)中的()必须带上！
                3：param list是函数的形参列表；
        4：函数指针的调用：
            (*pointerName)(实参列表);
            形态说明：
                *表名对pointerName的指针变量进行调用，由于()的运算优先级最高，所以*和pointerName必须使用()运算符，否则语义将会改变！
    9：c语言中的标准函数库：       
        基本库：<stdio.h>、<ctype.h>、<stdlib.h>、<string.h>、<time.h>
        常用库：<assert.h>、<limits.h>、<stddef.h>、
        其他库：<float.h>、<math.h>、<error.h>、<locale.h>、<setjmp.h>、<signal.h>、<stdarg.h>  
                
                


                    


                



                                          

                


                


                

                



