一：C语言基本特征：
    1：C语言属于静态类型编程语言，C源程序需要先编译链接成可执行文件，需要执行程序时再由操作系统执行该可执行文件来运行程序；由于提前将源程序编译链接为更切近硬件的二进制的可执行文件，因此C语言编写的程序运行效率较高；
    2：C语言允许直接访问物理地址，可以直接对位、字节、内存地址进行操作，因此可以开发偏底层的应用程序，并且其执行效率非常高；
    3：C语言在编程方式上仅支持面向过程编程，不支持面向对象编程；

二：C语言标准：
    1：C89和C90标准：
        C89来源：ANSI在1989年批准通过了C语言语法规范以及C语言标准库，因此称之为C89标准或者ANSI C；
        C90来源：ISO在1990年采用ANSI批准通过的C语言语法规范及C标准库，因此称之为C90标准或者ISO C；
        C89标准和C90标准指的是同一个标准；该标准也是编译器支持度最高的标准；
    2：C99标准：
        C89/C90标准发布之后，C语言标准委员会又不断的改进C语言；并最终在1999年开发布了新的C语言标准，并称之为C99标准；
        C99标准引入了许多新的特性：内联函数、可变长度数组、灵活的数组成员、复合字面量、支持不定参数个数的宏定义，在数据类型上还引入了long long int以及复数类型等新特性；
        目前对C99标准的支持在GCC以及Clang都能达到90%以上，但是Visual Studio目前支持度并不是特别高；
    3：C11标准：
        C语言标准委员会在2011年发布了新的C语言标准，称之为C11标准；C11在C99的基础上又引入了字节对齐说明符，泛型机制，对多线程的支持、静态断言、原子操作以及对Unicode的支持等特性；
    4：目前尽量使用C89/C90标准或者C99标准，因为编译器对C11标准的支持程度有限，尽量避免使用；

三：C语言执行流程：
    概述：
        由于C语言是静态类型语言，需要先编译链接成可执行文件；在执行时由操作系统执行该可执行文件；因此C语言的执行流程需要经过如下5个过程：
            1：编写C源程序；
            2：对C源程序预处理得到预处理文件；
            3：对预处理文件编译得到汇编文件；
            4：对汇编文件汇编得到目标文件；
            5：将目标文件链接得到可执行文件
    详细流程：
        1：编写源程序：
            1：C源程序即由C语言编写的C程序，
            2：一个C源程序可以有一个或者多个C源文件组成，每一个C源文件都以.c作为后缀，一个C源文件的内容则由若干个函数和声明语句组成；
            3：一个C源程序必须要有且只能有一个主函数，如果一个C源程序由多个C源文件组成时，主函数可以放在任意一个C源文件中；

        2：进行预处理，得到预处理文件：
            1：一个C源程序中包括若干个函数以及声明语句，声明语句中往往会有#include包含头文件的代码以及宏的使用，将源程序中#include包含头文件的代码替换成头文件的真正内容，以及将代码中的宏替换为宏真正的值，这个过程称之为预处理；
            2：预处理命令(gcc编译器)：gcc -E ./test.c -o test.i
            3：预处理完成后得到预处理文件，预处理文件以.i作为后缀，仍然是C语言组成的文本文件，可以通过文本编辑器打开；其中：#include代码全部被替换为头文件真正的内容，程序中使用到的宏也会被替换成宏真正的值；因此一般预处理文件的大小会大于C源程序文件；

        3：对预处理文件进行编译，得到汇编文件：
            1：此处的编译并非指将C预处理文件直接编译为二进制的目标文件，而是指将预处理文件转换为特定汇编代码组成的文本文件；
            2：编译命令(gcc编译器)：gcc -S ./test.c -o ./test.s
            3：编译完成之后得到汇编文件，汇编文件以.s作为后缀，是一个由特定汇编代码组成的文本文件，可以通过文本编辑器打开查看；

        4：对汇编文件进行汇编操作，得到C源程序文件的二进制目标文件：
            1：汇编的过程是将编译完成后的汇编文件转换成二进制的目标文件的过程；
            2：汇编命令：gcc -c ./test.s -o ./test.o
            3：汇编完成之后得到汇编文件，以.o作为后缀，是一个二进制的目标文件；

        5：对目标文件进行链接操作，得到最终的二进制可执行文件：
            1：一个可执行文件包括四个部分：启动代码，使用到的库函数代码，C源文件汇编得到的目标文件，组成C源程序的其他C源文件汇编得到的目标文件；上一步汇编完成之后只是得到了一个C当前源文件的目标文件，还缺少启动代码、引用到的库函数代码以及组成C源程序的其他C源文件的目标文件，因此还不能作为可执行文件运行起来；
            2：链接的过程即为将当前C源文件汇编得到的目标文件，启动代码，库函数代码和组成C源程序的其他C源文件的目标文件合并成为一个完整的可执行文件的过程；
            3：链接命令：gcc -o ./test.out ./test.o ./a.o ./b.o
            4：链接完成之后即可得到最终的可执行文件，在linux平台上以.out作为后缀，在windows平台上，以.exe作为后缀！由于linux平台对于文件后缀并无要求，因此.out可以省略；

        6：特别注意：
            1：链接过程中导入库函数代码时，仅仅只会导入C源程序使用到的库函数代码，并不会将整个库的所有代码导入；
            2：如果一个C源程序是由多个C源文件组成的，在链接时需要将多个C源文件的目标文件链接起来，而不仅仅只是得到包含主函数的C源文件的目标文件；

四：编译器：
    Linux上的常用的编译器为：gcc（最终可执行文件的后缀名为.out）
    windows上常用的编译器为：Cygwin（最终可执行文件的后缀名为.exe）

五：C语言基本语法规范：
    1：C源程序组成：
        1：一个C源程序可以由一个或者多个C源文件组成； 
        2：一个C源程序的每一个C源文件都以.c作为后缀；
        3：每一个C源文件都是有若干个声明语句(预处理文件的引入、宏的定义、类型的定义、全局变量的声明、函数的声明)以及若干个函数组成；
        4：一个C源程序必须要有并且只能有一个主函数；这个主函数可以放在任意一个C源文件中；
        4：C程序执行时，从主函数开始执行，并从主函数结尾，并将执行状态以整数的形式返回给执行环境；

    2：C语言基本语法：
        1：以;作为语句结束符号；
        2：以{}作为代码块包裹符号；
        3：以//作为单行注释，以/* ... */作为多行注释；
        4：标识符命名规范：
            1：以数字，字母，下划线组成；
            2：不能以数字开头；
            3：不能和关键字冲突；
            4：严格区分大小写；
            5：避免使用_或者__开头；
            6：避免使用拼音和英语混合式命名！
        5：一个C源文件结构上由两部分组成：1：函数、2：函数外部的声明代码；声明代码只能是以下几种代码类型：全局变量的声明，宏的定义，类型的定义，预处理语句，函数的声明语句；其余具备运算能力或者逻辑处理能力的语句都必须放在函数内部！

六：主函数：
    1：一个C源程序必须要有，并且只能有一个主函数；
    2：主函数可以放在任意一个C源文件中；
    3：C程序执行时，从主函数开始执行，并从主函数结尾处结束执行；并将执行状态以整数的形式传递给操作系统；
    4：主函数的名称只能是main，不能自定义为其他名称；
    5：主函数的定义方式：
        标准定义方式：
            1：int main(void){/* ... */}
            2：int main(int argc,char *argv[]){/* ... */}
        非标准定义方式：
            3：int main(int argc,char *argv,char *envp){/* ... */}
    5：主函数的形参说明：
        1：按照标准方式定义，可以选择以第一种方式声明，即不接受任何参数，直接声明为void；
        2：按照标准方式定义，也可以选择以第二种方式声明，接收两个参数；其中：
            int argc表示以命令行执行该程序的可执行文件时传入参数的个数；
                如果没有传递任何参数时，其值为1，因为可执行文件本身的名称也算是一个参数；
                如果有传入参数时，其值为参数个数+1；
            char *argv[]：一个字符串数组，每一项都指向使用命令行执行该程序时传入的字符串参数；
                其中argv[0]表示可执行文件的名称；
                其余传入的参数可以通过argv[1]~argv[argc-1]获取；
        3：按照非标准形式定义时，会在第二种定义的方式上多一个envp参数，表示执行该可执行文件时的环境信息，若干个字符串，每一个字符串都以键值对的形式表示环境信息；该参数表示的唤醒信息也可以在程序中通过getenv()标准函数获取；
    6：主函数的执行结果：
        C源程序从主函数开始执行，也从主函数结尾处结束执行；在主函数执行结束后，会将执行状态以整数的形式传递给操作系统；
        1：返回值是0或者EXIT_SUCCESS，表示程序执行过程一切顺利；成功执行完成！
        2：返回值是任何其他非0值，尤其是EXIT_FAILURE，则表示程序执行时出现问题；并未成功完整执行；
        3：mian函数并非必须调用return显式的返回一个整数值，如果程序运行到main()的右' } '处，将会自动向执行环境返回状态值0，如果执行发生异常则将会自动向执行环境返回非0状态值；
        4：main()函数的结束等效于在主线程中调用标准库函数exit(),exit()的参数将会作为main()的返回值；

七：C语言常用的输出方式：
    1：输出单个字符:
        putchar()       如：putchar('c')

    2：输出字符串：
        puts()          如：puts("string")

    3：格式化输出任意数据：
        printf()        
        1：基本使用方式：printf("格式化字符串",var1,var2,var3)
        2：格式化字符串由：自定义字符、格式化字符组成；其中自定义字符将会原样输出，格式化字符会按照顺序格式化待输出变量的值，并将格式化之后的值填充在格式化字符的位置，和自定义字符组成最终的字符串输出；
        3：格式化字符组成：%[flag][width][.precision][type]
        4：flag：
            -：默认输出是右对齐，带上-之后则为左对齐；
            +：正数带上+号，负数带上-号；
            #：对于小数，强制输出小数点，对于八进制，十六进制，二进制，带上前缀；
            空格：用于数字：正数加空格，负数加负号；
        5：width：最小宽度限制，对于字符串，如果字符串字符个数不足如果不足将会使用空格补齐，如果超出之后将会自动失效；
        6：.precision：
            对于 int，.precision 表示最小输出宽度
            对于 float，.precision 表示输出精度。
            对于 str，.precision 表示最大输出宽度。
        7：type:指定需要将变量格式化成指定的数据类型：
            字符/字符串：
                        %c          //格式化成字符类型
                        %s          //格式化成字符串类型
            浮点数：
                        %f          //格式化成单精度(float)类型的小数形式
                        %lf         //格式化成双精度(double)类型的小数形式
                        %e          //格式化成单精度(float)类型的指数形式
                        %le         //格式化成双精度(double)类型的指数形式
                        %E          //格式化成单精度(float)类型的指数形式(以大E表示)
                        %lE         //格式化成双精度(double)类型的指数形式(以小e表示)
            十进制整数：
                        %d          //格式化成十进制、有符号、int类型整数
                        %hd         //格式化成十进制、有符号、short类型整数 
                        %ld         //格式化成十进制、有符号、long类型整数
                        %u          //格式化成十进制、无符号、int类型整数
                        %hu         //格式化成十进制、无符号、short类型整数 
                        %lu         //格式化成十进制、无符号、long类型整数
            八进制整数：
                        %o          //格式化成八进制、无符号、int类型整数
                        %lo         //格式化成八进制、无符号、long类型整数
                        %ho         //格式化成八进制、无符号、short类型整数
            十六进制整数：
                        %x          //格式化成十六进制、无符号、int类型整数
                        %lx         //格式化成十六进制、无符号、long类型整数
                        %hx         //格式化成十六进制、无符号、short类型整数

八：C语言变量声明：
    C语言中变量使用基本规范：
        1：C语言中变量使用之前必须先声明，后使用；
        2：声明变量时，必须指明变量的数据类型，变量名称，如有必要可以赋上初始值；
        3：变量声明时，即确定该变量的数据类型；
        4：在程序运行过程中，变量只能指向和其数据类型相同的数据，不能指向其他数据类型的数据；

    C语言中变量命名规范：
        1：C语言变量名必须遵守C语言标识符命名规范；
        2：C语言变量推荐采用小写+_分割式命名；如：var_name

    C语言中的全局变量和局部变量：
        全局变量：
            在函数外部声明的变量称之为全局变量；
            全局变量声明位置：
                必须在使用之前声明该全局变量
            全局变量初始值：
                如果全局变量在声明的同时赋予初值则全局变量的初值即为所赋的值；
                如果全局变量在声明的同时并未赋值，则初值为0；
                全局变量只能在函数外部声明以及初始化，在函数外部不能参与任何赋值、运算以及逻辑处理；
            全局变量分为普通全局变量和静态全局变量：
                普通全局变量：
                    即不含任何特殊含义的全局变量；
                声明方式如：  
                    int a=1;
                普通全局变量的生命周期：
                    普通全局变量的生命周期和当前程序的生命周期一致，程序开始时初始化该全局变量，程序运行结束之后释放该全局变量；
                普通全局变量的作用域：
                    普通全局变量的作用域是组成c源程序的所有源文件；即多个c源文件中出现同名普通全局变量会冲突
                    普通全局变量可以在别的文件中通过extern引用;引用方式：extern date_type var_name

            静态全局变量：即作用域只在当前文件的全局变量：
                声明方式：
                    static int a=1;
                静态全局变量的生命周期：
                    静态全局变量的生命周期和当前程序的生命周期一致，程序开始时初始化该全局变量，程序运行结束之后释放该全局变量；
                静态全局变量的作用域：
                    静态全局变量的作用域只在当前C源文件内部；不会和其他c源文件中的同名全局变量冲突！
                    静态全局变量 不 可以在别的C源文件中通过extern引用
        
        局部变量：
            在函数内部声明的变量称之为局部变量；
            局部变量的声明位置：
                    对于c89/c90规定，在任何执行语句之前，在块的开头声明所有局部变量；
                    对于c99和c++中则没有这个限制，局部变量声明可以放在首次调用之前的任意位置； 
            局部变量初始值：
                如果声明局部变量之后未赋值，只会为其分配指定大小的内存空间，初始值是未知的，具体和分配的内存空间之前的值是一样的；
            局部变量作用域：
                只能在当前函数中，变量声明之后的代码块中使用；
            局部变量分为自动局部变量和静态局部变量：
                自动局部变量 auto
                    1：声明方式如：int b=3; 等同于auto int b=3;
                    2：该变量只能在所声明的函数中使用；其他函数不能调用；
                    3：其生命周期和函数保持一致，函数被调用时即初始化该变量，函数执行完毕之后即释放该局部变量；
                    4：自动局部变量如果不赋初值，其初始值是不确定的；

                静态局部变量 static
                    1：声明方式：static int a=12;
                    2：该变量只能在所声明的函数中使用；其他函数不能调用；
                    3：其生命周期和程序运行的生命周期一致，该特征和自动局部变量不同；
                        1：函数首次调用时即初始化该静态局部变量，但是函数运行完毕并不会释放该静态局部变量；并且在首次调用之后再次调用时不再初始化，其值为上次运行完毕最后一次对该变量修改的值；
                    4：如果静态局部变量不赋初值，其初始值不确定；
                    
                在函数内部定义的变量、数组、结构体、共用体等都称为局部数据。在很多编译器下，局部数据的初始值都是随机的、无意义的、未知的，或者为其分配的内存空间上次使用之后残留下来的数据，而不是通常认为的“零”值。
九：运算规则：
    1：运算级别：
        赋值运算= < &&和|| < 关系运算 < 算术运算 < ! < ()
    
    2: ()运算符：
        优先级最高，表示优先计算()里面的运算表达式；
    
    3: 算术运算：
        运算符：+ - * / % ++ --
        使用范围：只能适用于数字
        运算方向：从左至右运算
        级别：仅次于逻辑运算中的' ! '，大于关系运算
        备注： 
            对于除法：
                如果除数和被除数都是整数，那么得到的结果也是整数；
                如果除数和被除数有一个是小数，那么得到的结果也是小数；并且是double类型的小数；
            对于取余运算：
                C语言中的取余运算只能针对于整数进行，即%两边都必须是整数，否则编译器将会报错！
            对于自增自减运算：
                前自增在赋值时先运算后赋值；
                后自增在赋值时先赋值后运算；
    
    4：关系运算：
        运算符：< > <= >= == !=
        运算方向：从左至右
        级别：整体级别大于逻辑运算符的&&和||，小于算术运算符，但是同级别内< > <= >=的级别大于==和!=；

    5：逻辑运算：
        运算符：&& || ！
        运算方向：从左至右
        级别：&& 和 || 小于关系运算符，！小于()大于算术运算符
        备注：运算结果是一个Bool值
    
    6：赋值运算符：
        运算符：= += -= *= /= %= 
        方向：将右侧的值赋给左侧
        级别：级别最低；

    7：位运算：直接对二进制位操作的方式
        c语言包括6种位运算：& | ^ ~ << >>
        &：按照二进制位求交运算
        |：按照二进制位求或运算
        ^：按照二进制位求异或运算
        ~：按照二进制位取反
        <<:按照二进制位全部左移，高位丢弃，低位补0；
            （如果数据较小，被丢弃的高位不包含 1，那么左移 n 位相当于乘以 2 的 n 次方。）
        >>：按照二进制位全部右移，低位丢弃，高位补0或者1；最高位是0就补0，最高位是1就补1；
            （如果被丢弃的低位不包含 1，那么右移 n 位相当于除以 2 的 n 次方（但被移除的位中经常会包含 1） 
            
    8：几种操作符号的优先级： 
        1：定义中被括号( )括起来的那部分，优先级最高；
        2：后缀操作符：括号( )表示这是一个函数，方括号[ ]代表[]之前的变量名表示的是一个数组，优先级次之；
        3：前缀操作符：星号*表示“指向xxx的指针”，&取地址符表示取某个变量的地址，优先级低于后缀操作符；

十：流程控制：
    1：条件：
        1：if..else条件语句：
            if(表达式)
            {

            }
            --------------------------
            if(表达式)
            {

            }else if(表达式)
            {

            }else{

            }
            --------------------------
            if(表达式)
            {

            }else{

            }
        2:switch条件语句：
            switch(var){
                case 1:
                    code..
                    break;
                case 2:
                    code..
                    break;
                default:
                    code...
            }
            备注： 
                1：switch中只能是整数，不能是浮点数或者其余数据类型；
                2：case只能是整数，不能是浮点数或者其余数据类型
                3：多个分支有共同处理方式，则多个分支可以放在一起，只在最后一个分支结束时使用break语句；
                4：default不是必须的；当所有的case都无法匹配时，将会走进default;
                
        3：? :   三目运算符；

    3：循环：
        for(int i=0;i<n;i++)
        {

        }
        --------------------------
        while(表达式)
        {

        }
        --------------------------
        do
        {

        }while(表达式);(;一定要有)

    4：跳出循环：
        1：break;结束当前循环；
        2：continue;结束当前循环，并开始新的循环！

十一数据类型：
    基本数据类型：
        1：整数类型：
            short int                     2字节(16位)                -32768到32767      有符号
            (可简写为：short)                 
            unsigned short int            2字节(16位)                0~65535       无符号
            (可简写为：unsigned short) 

            int                           2/4字节(16位/32位)         -32768到32767或者-2e32到2e32-1       有符号
            unsigned int                  2/4字节(16位/32位)         0~65535或者0~2e33-1      无符号
            (可简写为：unsigned)            
            (int类型具体占用几个字节和平台以及编译器有关)

            long int                      8字节(64位)               -2e64到2e64-1       有符号
            (可简写为：long)
            unsigned long int             8字节(64位)               0~2e65-1       无符号  
            (可简写为：unsigned long)

            在C99标准中又新增了long long int类型：
            long long int                 8字节(64位)               -2e64到2e64-1       有符号
            (可简写为：long long)
            unsigned long long int        8字节                     0~2e65-1      无符号
            (可简写为：unsigned long long)

            修饰类型：
                signed      有符号类型，最高位是符号位，不能存储数值；
                            该数据类型既可以存储正数也可以存储负数，数值区间在负数的最小值和正数的最大值之间；
                            是默认类型，无需显式的声明；
                            
                unsigned    无符号类型，最高位可以用来存储数值；该数据类型只能存储正数，不能存储负数，数值区间在0到正数最大值之间，
                            使用unsigned修饰数据类型可以表示更大的正数区间；同样大小位数的存储空间可以存储更多的正数；因此如果没有负数需求，尽量使用unsigned类型的整数类型；
                            不是默认类型，使用时必须显式的声明；

            数据溢出：
                向上溢出
                    数据向上溢出时，将会从数据类型的最小值开始从新计数，不同的是：
                        有符号类型溢出之后，将直接从负值最小值开始从新计数(向上递增)；
                        无符号类型溢出之后，将直接从0开始从新计数(向上递增)；
                向下溢出：
                    无论有符号还是无符号，均是从正值最大值从新计数(向下递减)；不同的是有符号类型和无符号类型的正值最大值不同！
            注意：
                所有的整数类型表示的数值范围都和具体的平台以及编译器实现有关，C语言规范并未明确要求某种类型占据多少字节；上述范围表示linux平台GCC编译器下的数值范围；

        2：浮点数：
            float                       4字节                 6位小数（精确度）、单精度
            double                      8字节                 15位小数（精确度）、双精度
            long double                 16字节                19位小数（精确度）、双精度
            备注：
                1：c语言中浮点数有时候无法精确表示一个小数值，只能近似的表示该小数；原因在于10进制转二进制的时候采用的是除2取余倒序排列法，有些情况下一个十进制数无法被2整除，但是浮点数精度位数有限制，就导致了在精度位后一位出现四舍五入的现象，最后导致无法使用二进制精确表示一个十进制浮点数；
                2：浮点数在表示形式上可以使用小数形式表达，也可使用指数形式表达；即：1.22或者122e-2或者122E-2；
                3：在存储上，浮点数的整数部分和小数部分是分开转换成二进制存储的；
                4：对于无法被2整除的浮点数参与算数运算时，其损失的精度会更多；原因在于有些十进制的浮点数在二进制时只能近似的表达；
        
        3：字符类型：
            1：C语言基本数据类型中没有字符串类型，只有字符类型；标识符为char;值为单引号''包裹的单个字符；其中双引号"a"包裹的单个字符和单引号'a'包裹的字符意义不同,"a"表示字符串a,'a'表示字符a;
            2：声明一个字符时使用char来声明，但是字符实际保存时则保存的是字符在字符集中对应的编码值；由于在C89中，默认使用ASCII字符集，因此字符在实际保存时保存的是ASCII字符集中字符对应的编码值；
            3：char类型的大小是一个字节；其范围在-128～127之间，unsigned char的表示范围在0～255之间；
            4：字符类型在赋值时可以使用单引号 '' 包裹的单个字符；也可以直接赋值为char/unsigned char范围内的整数；
            5：宽窄字符：
                1：以char声明的，以''包裹的称之为窄字符，由窄字符组成的字符串称之为窄字符串；窄字符默认以ASCII编码存储；
                2：对于中文字符，在windows平台采用utf-16存储，使用2个字节存储一个中文字符；但是在unix平台采用utf-32存储，即使用4个字节存储一个中文字符；
                3：由于中文字符在不同平台不同编译器的长度表示不一致，c标准推出了wchar_t类型，wchar_t的类型的长度由编译器决定！wchar_t类型位于<wchar.h>头文件中！
                4：使用wchar_t类型表示的字符称之为宽字符，由宽字符表示的字符串称之为宽字符串；使用wchar_t这种宽字符需要在字符前加L；如：wchar_t d = L'国';  //中文汉字 
            6：宽字符的打印：
            putwchar():只能输出宽单个字符，且要使用setlocale(LC_ALL,"zh_CN");来设置本地化
            wprintf():  用于输出宽字符串
                        宽字符标识：%ls;
                        用法：和printf完全一样
            7：常用的转义字符：
                1：转义字符以\或者\x开头，以\开头表示后跟八进制形式的编码值，以\x开头表示后跟十六进制编码值，对于转义字符来说，只能使用八进制或者十六进制；
                2：转义字符的初衷是用于ASCII编码表示一些非打印字符，因此取值范围有限：
                    八进制形式的转义字符最多后跟三个数字，即\ddd,最大取值\177;
                    十六进制形式的转义字符最多后跟两个数字，即\xdd，最大取值\x7f
                    超出范围的转义字符是未定义的，如果是用超出范围的转义字符，编译器要么报错，要么直接输出！
                3：对于ASCII编码，0~31范围内的字符为控制字符，只能用转义字符来表示，常见的转义字符如下：
                    \a 	响铃(BEL)     
                    \b 	退格(BS)  
                    \f 	换页(FF)  
                    \n 	换行(LF)  
                    \r 	回车(CR)
                    \t 	水平制表(HT)     一般相当于四个空格，或者 tab 键的功能    
                    \v 	垂直制表(VT)    
                    \' 	单引号 
                    \" 	双引号 
                    \\ 	反斜杠 

        4：布尔类型：
            C89标准中是没有布尔类型的；
            C99标准中添加了_Bool类型，用于表示布尔值；即：true和false
            _Bool大小仅为一位，存储0/1；0表示false,1表示true；
            C99标准中能够自动将其余数据类型转换为布尔类型的值；
        
        5：NULL类型：
            1：NULL本质上不是一种数据类型，而是一个宏,而且宏的值为一个指针，因此NULL的本质是一个指针；
            2：NULL的原型：#define NULL ((void *)0)
            3：对NULL的理解：NULL是一个指针，其值为0，但是该0和数值0并不相同；NULL表示的是一个存储单元的地址，只是该存储单元的地址值是0，并且该存储单元中存储的数据类型未知；
            4：特别注意：C语言并未规定NULL的指向，只是大部分标准库约定俗成将NULL指向了地址为0的存储单元；
        
        6：基本数据类型之间的转换：
            1：自动类型转换：
                自动类型转换是由编译器根据计算需求，自动将数据类型进行转换的一种方式；
                自动类型转换发生在两种情况下：
                    1：赋值时：如果类型转换合法，将会把右侧的变量转换为左侧变量的数据类型，然后赋值给左侧变量，右侧的数据类型不会被改变！但是将高精度值赋给低精度值时将会发生精度损失
                    2：运算中：在运算时，编译器会将所有的数据的类型转换为同一种数据类型，然后再进行计算！
                        1：转换方向：
                            char/short->int->long
                                             ->float->double
                              转换方向为数据长度增加方向(高精度方向)进行;
                        2：所有的浮点运算都是以双精度进行的，即使运算中只有float类型，也将全部转换为double进行运算；
                        3：需要注意的是存储运算结果时由于运算结果类型的变化导致数值的溢出！

            2：手动类型转换：
                强制类型转换方式：(目标数据类型)待转换变量  
            
            3：类型转换的注意事项：
                1：无论是强制类型转换还是自动类型转换，转换改变的仅仅是结果，源数据的类型并不会改变！
                2：无论是强制类型转换还是自动类型转换，高精度往低精度转换都会发生精度损失！
                3：无论是强制类型转换还是自动类型转换，数据类型转换要合适，不能在不相干的数据类型之间转换，否则编译器将会报错！
                4：无论是强制类型转换还是自动类型转换，都要注意类型转换之后溢出的问题，尤其在自动类型转换中；
    复杂数据类型：
        指针：
            1：指针：
                概念上理解：
                    指针只是一个概念，一个不存在的虚拟概念,像一个箭头，指向某个存储单元；
                程序上理解：
                    指针的具体体现就是指针变量，指针变量就是一个普通的变量，只是和其他变量相比指针变量的值是某个存储单元的地址；通过该指针变量的值即可找到对应地址的存储单元，进而能够访问到该存储单元中的数据；

            2：存储单元和内存地址：
                1：数据必须先要加载至内存中，才能够被CPU获取并处理；
                2：计算机的内存在系统中会被分割为若干个1字节大小的存储单元，每一个存储单元都会有一个编号，代表该存储单元，称之为存储单元的地址或者内存地址；通过这个地址就可以找到存储单元，并访问其中的数据；在初始化变量时，系统会按照变量占用的字节数，分配对应个数的存储单元组成一个内存块来存储对应的数据； 
                3：内存中存储单元的地址是从0开始的，以十六进制表示，类型为unsigned int；
                4：理论上：一个指针变量可以指向计算机中的任何一块内存，不管该内存有没有被分配，也不管该内存有没有使用权限，只要把地址给它，它就可以指向;
            
            3：指针和数据：
                指针是一个虚拟的概念，表示对存储单元的指向，反映在程序上则为指针变量，其值为某个存储单元的地址；
                数据则是一个明确的值，存储在存储单元中，是存储单元的内容；
            
            4：指针变量和普通变量：
                指针变量和普通的变量一样都是变量，都是用来存储数据的；区别在于：
                    1：指针变量的值表示某一个存储单元的地址；普通变量的值表示某一个存储单元中的内容；
                    2：指针变量的数据类型固定为unsigned int类型的16进制整数，并从0开始计数；普通变量的数据类型根据变量声明时的数据类型而定；
                特别注意：虽然指针变量存储的是unsigned int类型的整数，但是不可以将指针变量和存储unsigned int类型的普通变量进行运算！其意义完全不一样！

                **关于指针变量和普通变量声明的思考**：
                    
                    1：相同点在于：
                        无论是指针变量还是普通变量，在程序的角色上都是变量，都是用来存储数据的，并且其代表的数据都是在某个内存块中存储的，即指针变量的值虽然表示某个存储单元的地址，但是值本身仍然是在某个内存块中存储；而内存块则由一个或者多个存储单元组成(比如声明一个short类型的变量，系统就会分配一个内存块，占用2字节大小，变量的值就是该2个字节中的内容)；
                    2：不同点在于：
                        1：意义不同：指针变量的值表示某个存储单元的地址，但是普通变量的值表示某个存储单元的内容；
                        2：数据类型不同：指针变量的类型固定为unsigned int类型；普通变量的类型则取决于该变量声明时所指定的类型：
                        3：运算方式不同：指针变量的运算本质上是移动指向存储单元的地址；普通变量的运算本质上是对存储单元中内容的改变；
                        
                    3：指针变量的值也是存储在多个存储单元组成的内存块中，存储指针变量的值的内存块也是有地址的，因此同样也可以被其他指针指向存储当前指针变量值的存储单元；
            
            5：指针变量的声明：
                声明方式1：数据类型 *变量名
                声明方式2：数据类型 * 变量名
                备注： 
                    1：数据类型是指该指针指向的存储单元中存储的数据的数据类型；一旦声明完成之后，该指针指向的存储单元将只能存储声明的数据类型的数据；
                    2：*表明该变量是一个指针变量，该变量的值表示的是某一个存储单元的地址，而不再是某一个数据；*在指针变量声明时，可以有空格也可以紧贴变量名；
                    3：变量的命名规范和普通的变量命名规范一样；
            
            6：指针变量的运算；
                1：&:该运算是取地址符；该运算符可以使用在普通变量和指针变量之前，用来获取变量的内容在内存中的地址；
                2：*:该运算符是取值符，可以通过*获取指针变量指向的存储单元中所存储的值；
                3：设置存储单元中的内容：*指针变量 = 值；即可将值赋值给指针变量指向的存储单元；
                4：赋值：指针变量的值可以赋值给另一个指针变量(1：赋值双方必须都是指针变量；2：两个指针变量必须是相同的数据类型)，赋值完成之后，两个指针变量指向同一个内存地址；
                5：加减运算：指针变量允许加上或者减去一个整数；
                6：自增/自减运算：指针变量允许进行自增自减运算；
                7：指针变量加减整数或者自增自减运算说明：
                    1：普通变量加减某一个整数是指给存储单元中存储的数据本身加/减去n，不会引起数据在内存中存储地址的改变；
                    2：指针变量加减某个整数m或者自增自减运算:
                        微观上看：指针变量加/减某个整数m，是指将指针变量的指向跳过n*m个存储单元，n是指当前指针变量数据类型在当前平台所占字节个数；
                        宏观上看：指针变量的加减运算改变的是当前指针对存储单元的指向；
                    3：不允许对指针变量做除过加减/自增自减以外的任何其他算术运算；
                    4：普通的指针变量做自增自减或者加减运算并无任何实际意义；指针的指向会改变，但是指向新的存储单元中的数据则是不确定的；
                    5：对于数组或者字符串,由于其占用的是一段连续的存储单元，因此指针变量的加减/自增自减改变的是指针指向的元素位置，其值是可以预料的，通过对指针位置的改变可以获取到相邻的元素值，是有意义的；

            7：空指针：
                1：在函数中声明一个指针变量，如果不为该指针变量进行初始化，该指针变量的值就是不确定的，因此该指针变量指向哪一个存储单元也是未知的，大多数情况下是未分配或者没有读写权限的；如果对于这种指针变量不做处理，对程序的健壮性有影响；
                2：如果一个局部指针变量未被初始化的时候，推荐赋值为NULL，即将该指针设置为空指针；
                3：空指针的意思为：将一个指针变量的值设置为NULL；即该指针指向地址为0的存储单元，但是该存储单元中存储的数据类型以及数据内容是未知的！
            
            8：二级指针：
                1：指针变量的值也是存储在多个存储单元组成的内存块中，存储指针变量值的存储单元也是有地址的，指向存储指针变量值的存储单元的指针称之为二级指针；
                2：从宏观角度来理解：二级指针即为指向另一个指针的指针；
                  从微观角度来理解：二级指针变量仍然只是一个普通的指针变量，其值仍然代表的是某一个存储单元的地址；只是其指向的存储单元中的值代表的是另一个存储单元的地址；
                3：二级指针变量仍然只是一个普通的指针变量，数据类型仍然为unsigned int，其值仍然代表的是某一个存储单元的地址；
                4：二级指针需要使用**来声明，同理三级指针需要使用***来声明；
                4：对二级指针进行*取值运算之后得到的结果是另一个存储单元的地址，对得到的存储单元的地址再次进行*取值运算之后将会得到该存储单元指向的内存块中的值；因此如果是取值，需要使用**来对二级变量取值，同理三级指针需要使用***;

            9：野指针：
                1：所谓野指针，是指没有明确合法指向的指针，称之为野指针；
                2：野指针随机指向一块空间，该空间中存储的可能是其他程序的数据，甚至是系统数据，其指向完全不确定，因此不能对野指针所指向的空间进行存取操作，否则轻则引起程序崩溃，重则可能导致整个系统崩溃！
        
        数组：
            1：数组：
                1：数据的有序集合称之为数组
                2：数组中的每一个值称为数组的元素
                3：数组中元素的个数称之为数组的长度
                4：数组中每一个元素按照顺序排列，可以通过元素的序号访问数组元素；

            2：数组的声明：
                1：数组在使用之前需要先声明后使用；
                2：数组的声明方式：数据类型 数组名[数组长度]；数据类型代表数组中元素的数据类型；
                    对数组声明的几点说明：
                    1：数组声明时即要确定数组的长度，声明时确定的长度即为数组最多容纳的元素数量；一旦声明完成，该长度不允许再被改变，存储数组元素也不允许超过做大限制，否则将会溢出；
                    2：数组声明时即确定数组元素的类型，一旦声明完成，数组中只能存储指定数据类型的数据；不允许存储其他类型的数据；
                    3：对于数组而言，在函数内部声明数组时，如果声明完成后未初始化，那么数组中的元素则是不确定的；
                    4：[]符号为数组符号，表示其之前的紧跟的变量为数组；在符号优先级中仅次于()，高于取地址运算符&和取值运算符*;

            3：数组的赋值：
                1：数组可以在声明的同时完成赋值：
                    1：完全赋值：即按照所声明的数组长度，填入相同个数的值；
                                如：int arr[3] = {1,2,3}
                            备注：
                                1：完全赋值时数组可以不用显式指定长度；
                                    如：int arr[] = {1,2,3}

                    2：不完全赋值：赋值的个数少于数组声明时指定的个数；
                                如：int arr[3] = {1}
                            备注：
                                1：不完全赋值时，必须明确表示数组的长度；
                                2：不完全赋值时，数组未赋值的部分也会按照基本规则进行初始化：
                                    1：如果数组类型为：int,short,long,将直接赋值为整数0；
                                    2：如果数组类型为：char,将赋值为\0；
                                    3：如果数组类型为：float或者double，则将会赋值为0.0；
                2：数组也可以在声明完成之后进行赋值：
                    数组在声明完成之后只能通过下标一个一个对单个数组元素进行赋值，不能再使用{}整体进行赋值;

            4：数组使用时的注意事项：
                1：数组是占用一段连续的存储空间来存储数组元素的，这段连续的存储空间的长度为当前数组元素的数据类型在当前平台占据的字节个数m*数组声明时的长度n；
                2：数组元素在赋值的时候只能赋值数组声明的数据类型的值，不能赋值其他数据类型的值；
                3：C语言中数组是静态数组，即长度一旦声明好之后将不能再改变，插入数据的个数不能超过长度，否则将会出现溢出，也不能随意删除数据；
                4：固定长度的数组是在编译期间分配内存的；

            5：二维数组：
                二维数组的声明：
                    数据类型 数组名[一维长度][二维长度];
                二维数组的意义：
                    二维数组上类似于一个矩阵：一维长度指的是矩阵的行数，二维长度指的是矩阵的列数；
                二维数组的存储：
                    二维数组在概念上是二维状态存在，但是在内存中则是按照一维顺序排列的；
                二维数组的赋值：
                    1：分段赋值：按照二维数组的行数赋值
                        1：完全赋值：每一行都完全赋值,虽然是完全赋值，但是一维的长度一定要给出；   
                                    int a=[3][2] = {{1,2},{3,4},{5,6}}
                        2：部分赋值：每一行都只赋值一部分，默认从左向右赋值，其余未赋值的部分则按照数据类型自动填充；
                                    int a[2][4] = {{1,2},{3}}   会自动填充为:{{1,2,0,0},{3,0,0,0}}

                    2：连续赋值：按照一维的方式赋值，并且系统会按照二维的长度自动分行
                        1：完全赋值：从左向右按行赋值；此时可不必给出一维长度，系统会按照二维的长度自动分行；
                            int a[][2] = {1,2,3,4,5,6}   会自动分行为:{{1,2},{3,4},{5,6}}
                        2：部分赋值：从左向右按行赋值；其余则按照数据类型填充；
                            int a[3][2] = {1,2,3}   会自动分行为:{{1,2},{3,0},{0,0}}
                    
                    3：二维数组在声明完成之后赋值，只能按照数组元素一个一个赋值；不允许再整体赋值；
            
            6：数组与指针：
                1：数组一旦声明完成之后将占用的是一段连续的存储单元，占用存储单元的个数=数组声明时的长度*数组元素类型在当前平台占用的字节个数；数组的元素按顺序存储在这段连续的存储单元中,由于每一个数组元素的位置已经完全确定。所以数组元素的插入，获取，修改时间复杂度均为O(1)；

                2：数组名：
                    1：数组名仍然是一个变量，但是数组名既代表的是某一个数组整体；也是数组首个元素的指针，即数组的首地址；
                    2：C语言中在&运算符、sizeof运算符、数组声明时数组名代表整个数组，除上述三种情况以外，数组名均代表数组的首地址，即数组的第一个元素，此时本质上数组名是一个指针，保存的是数组第一个元素的地址；
                    3：如果数组名代表的是数组的首地址，则和指向数组第一个元素的指针变量等价，否则和数组指针不等价！

                3：数组指针：
                    1：指向数组中某一个元素的指针称之为某个数组的数组指针，数组指针和普通的指针并无区别，仅仅只是在意义上数组指针代表的是某个数组中的某一个元素的地址而已；
                    2：数组指针指向数组中的某一个元素，也仅仅只能够代表其所指向的数组元素，并不能够代表整个数组；即便数组指针指向的是数组的第一个元素，也只能代表数组的第一个元素，无法代表整个数组；数组指针和数组名本质上不同；
                    3：由于数组占用的是一段连续的存储单元，因此数组指针的加减和自曾自减即指向上一个或者下一个数组元素；因此通过某个数组指针也可以访问其他数组元素；

            7：数组的基本操作：
                1：获取数组长度：
                    int len = sizeof(数组名)/sizeof(数组元素类型)
                    注意：
                        1：此种方式计算数组长度时，数组名必须代表的是整个数组，不能是指向第一个元素的数组指针；
                        2：如果函数要求传入数组类型的数据，此时如果传入数组名则仅仅代表的是数组的首地址，并不能代表整个数组，根据传入的数组名也无法使用sizeof来计算数组的长度，数组长度需要单独传入；
                2：数组的取值：
                    1：通过数组名访问：数组名[下标]
                    2：通过指针的方式访问：*(数组名+下标)
                    3：通过数组指针访问：*(数组指针+n)

                3：数组的赋值：
                    1：通过数组名赋值：数组名[下标] = 值
                    2：通过指针的方式赋值：*(数组名+下标) = 值
                    3：通过数组指针赋值：*(数组指针+n) = 值  

            8：指针数组：
                1：指针数组是指数组的每一项都代表一个指针；本质上和普通的数组并无区别！

                2：指针数组的声明方式：
                    1：数据类型名 *数组名[数组长度]
                    2：数据类型名 *(数组名[数组长度])
                    3：注意安装符号运算优先级，后缀运算符的优先级高于前缀运算符，因此*后面的括号可以不用带；

                3：数组指针和指针数组的区别：数组指针指的是指向数组中某一个元素的指针；指针数组是一个数组，只是数组的每一项都是一个指针！

                4：对于指针数组声明方式的理解：
                    指针数组的声明方式为：数据类型名 *数组名[数组长度]；
                    1：根据C语言中的运算优先级规则来看，[]后缀运算符的优先级大于前缀运算符*，所以，先根据数组名之后的[]确定该变量是一个数组，在根据数组名之前的*以及数据类型来确定数组中的元素是指定数据类型的指针；
                    2：由于后缀运算符[]的优先级大于前缀运算符*；因此()可以有也可以没有；

                5：指针数组名的理解：和普通数组一样，在声明、&、sizeof()运算符中代表的是整个数组，即代表数组中的每一个元素；除此之外，指针数组名代表指向第一个数组元素的地址，由于第一个元素也是指针，所以指针数组名此时代表的则是二级指针；
            
            9：二维数组指针与二维数组：
                1：虽然二维数组在在存储上是一维线性连续存储的，但是概念上是二维的，二维数组类似于由若干个一维数组组成的一个大数组；
                2：相对于一维数组，指向一维数组元素的指针，称之为数组指针；那么同样，指向二维数组中的某一维的指针也被称之为数组指针，但是其代表某个一维数组的首地址，而非具体的数组元素；本质上是一个二级指针；
                2：二维数组指针的方式声明：数据类型 (*数组名)[n]; 如int (*p)[2]，指的是一维长度未知，二维长度为2的二维数组；
                3：关于二维数组和指针的理解：
                声明一个数组如：int a[3][2] = {{1,2},{3,4},{5,6}}
                    那么a即等价于a[0]，a[0]本质上则是指向数组{1,2};
                对于使用指针声明的方式而言：int (*p)[2]:p即为二维数组指针；指向二维数组中的某一维；
                4：对于二维数组名而言，在数组声明，sizeof(),&取地址运算符以外，其代表的是指向二维数组中第一维的指针，此时二维数组名是一个二级指针！

        字符串：
            1：C语言中以""来表示一个字符串，但是并没有专门的字符串类型，通常使用一个字符数组来存放字符串；因此在C语言中，字符串本质上是一个字符数组，在创建字符串时可以通过字符数组创建也可以直接通过""创建；

            2：对于使用字符数组的方式和""的方式创建字符串有本质的不同：
                1：存储区域不同：
                    1：如果字符串以字符数组的方式创建，那么该字符串是保存在全局数据区，可读可写；
                    2：如果字符串以""的方式创建，那么本质上是创建了一个字符串常量，存放在常量区，只具有可读权限；
                2：字符串变量名意义不同：
                    1：如果字符串以字符数组的凡是创建，那么字符串变量名和字符数组名完全相同；即：在&运算符、sizeof运算符、字符数组声明时，字符串变量名代表的是字符串整体；其余情况均只能代表字符串首个字符的地址；
                    2：如果字符串以""的当时创建，那么字符串本身以及字符串变量名均只能代表字符串首个字符的地址；即此时字符串本身以及字符串变量名都是个指针，指向字符串首个字符地址；不能代表字符串整体；
                3：字符串内容不同：
                    1：如果字符串以字符数组创建时，字符数组中的字符数和创建的字符串字符数完全相同；
                    2：如果字符串以""创建，那么实际保存字符串时会在字符串后面加一个'\0'来作为字符串的结束符号；实际保存该字符串数组的字符个数比字符串本身多1个字符；
            
            3：字符串的声明以及初始化：
                1：以数组的方式声明：字符串本身就是以字符数组的方式存放，因此可以通过字符数组的方式创建字符串：
                    声明：char str[n]
                    赋值：
                        1：按照数组的方式赋值，可以完全赋值，也可部分赋值：
                            char str[3] = {'s','t','r'}或char str[] = {'s','t','r'}
                        2：按照字符串的方式赋值，可以直接赋值为字符串常量：
                            char str[3] = {"str"}或char str[] = {"str"}或char str[] = "str"
                        3：字符串以数组的方式声明，一旦声明完成之后赋值，将只能按照字符一个一个赋值，不允许再整体赋值；

                    备注：以字符数组的方式声明的字符串，无论以何种方式初始化，都是在全局区域保存，具备读写权限，即可以对创建的字符串本身修改；

                2：以指针的方式声明：以""声明字符串时，字符串本身及字符串变量均是一个指针，指向字符串首个字符；因此可以通过指针的方式声明字符串；
                    声明：char *str
                    赋值：
                        1：按照数组的方式初始化：char *str = {"string"}
                        2：按照字符串的方式初始化：char *str = "string"
                    备注：以指针的方式声明的字符串，只能以""的方式初始化，并且该字符串存放在常量区，只具有可读权限，因此一旦声明完成将不能再对字符本身进行修改；

            4：获取字符串中的字符：
                字符串本质上是通过字符数组进行存储的，因此无论使用哪种声明方式都可以通过一下方式获取字符串中的字符：
                    1：数组的方式获取字符串中的字符：str1[0]; 或者：str6[n];
                    2：指针的方式获取字符串中的字符：*str1;   或者：*(str1+n);

            4：字符串的存储位置：
                1：通过字符数组的方式声明的字符串，其存储位置是在栈区或者全局数据区；应用程序具备读取和写入的权限！因此可以对字符串本身进行修改！同时也可以修改字符串变量的指向；

                2：通过字符指针的方式声明的字符串，其存储位置是在常量区；应用程序只有读权限，没有写入权限！不能够对字符串本身进行修改，但是可以修改字符串的指向！

            5：字符串的长度：
                1：使用sizeof(字符数组名)，如果以字符数组的方式声明，则sizeof的值即为字符串字符个数；如果以""的方式声明，则sizeof的值为字符串字符个数+1(原因是：C语言中会在字符串后加上'\0'作为字符串的结束符号)：
                2：使用string.h头文件中定义的strlen(字符数组名/字符串变量名)函数，该函数计算得到的长度则是字符串的实际长度！其余针对字符串操作的函数也是在string.h头文件中；
                3：注意'x'和"x"不同，'x'代表字符，"x"代表单字符字符串；

            6：对于字符串数组的理解：
                1：字符串数组声明：char *str[]={"string1","strign2"}中：
                    第一问：为何需要声明成char *str[] 这种格式：
                        1：从指针方面理解：以""声明的字符串本身代表的是字符串中首个字符的地址，即指向字符串中首个字符的指针；因此字符串数组本质上是一个指针数组；等价于：
                            char * str_item1 = "string1";
                            char * str_item2 = "string2";
                            char *str[] = {srt_item1,str_item2};
                        所以：char *str[]代表声明一个字符指针数组；

                        2：从字符数组方面理解：字符串数组中的每一个字符串本质上都是一个字符数组，因此字符串数组本质上也可以看做是一个二维字符数组；等价于：
                            char str_item1[] = {'s','t','r','i','n','g','1'}
                            char str_item2[] = {'s','t','r','i','n','g','2'}
                            char *str[] = {str_item1,str_item2};
                        所以：char *str[] 代表声明一个二维字符数组；
                        
                    第二问：字符串数组的名称代表什么意思：
                        1：从数组方面理解：字符串数组本质上是一个二维字符数组，因此字符串数组名等价于二维数组名；
                        2：从指针方面理解：字符串数组本质上是一个指针数组，字符串数组名指向第一个指针，因此字符串数组名等价于二级指针；
                
        结构体：
            结构体：
                1：结构体并非数据类型，而是由多种数据组合而成的一种数据结构模板，在创建结构体时需要注明组成该模板的每一个数据的类型和名称；
                2：因为结构体本身只是一种数据模板，并非数据类型，因此结构体本身不占据内存空间；
                3：结构体的意义在于，可以方便统一管理一组相关的数据；并且不限制数据的类型和个数；

            结构体变量：
                1：通过该结构体创建变量时，系统会按照结构体中的数据个数以及每一个数据的数据类型分配一段连续的内存空间；
                2：结构体变量是结构体的实体，代表真实的一组数据，因此结构体变量占有内存空间；
                3：结构体是模板，但是结构体变量代表的是按照该模板分配出的存储空间，可以存放一组结构体成员；

            结构体与数组：
                结构体：
                    1：既可以存储同种数据类型的数据，也可以存储不同数据类型的数据，
                    2：结构体中的数据是通过数据名称来访问的；
                    3：一旦声明了结构体，那么结构体内的数据个数以及每一个数据的数据类型、名称就已经确定，只能按照结构体的结构来存放数据；

                数组：
                    1：只能存储声明时所声明的数据类型，不能混合存储不同数据类型的数据；
                    2：数组中的数据只有索引，没有名称；可以通过索引来操作数组中的数据；
                    3：数组一旦声明时确定长度，就只能存放对应个数的数组元素，否则将会溢出；
                
            结构体的声明：
                声明：struct 结构体名称{
                    数据类型 数据名称1;
                    数据类型 数据名称2;
                            .
                            .
                };
                示例：struct Stu{
                    short age;
                    int   num;
                    char *name;
                };
                备注：
                    1：struct 关键字表示后面的代码块是一个结构体；
                    2：Stu即为结构体的名称；其命名必须符合C语言标识符命名规范；
                    3：结构体本质是一种数据集合的模板，声明了该模板中所包含的数据成员，以及每一个数据成员的类型，名称；
                    4：结构体可以嵌套其他结构体；

            结构体变量的创建：
                1：声明一个结构体类型的变量，称之为结构体变量；
                2：结构体变量的声明方式：
                    struct 结构体名 结构体变量名1，结构体变量名2；
                3：对于结构体变量的理解：
                    1：声明结构体变量时，系统将会按照预先声明的结构体成员数量及类型，分配一段连续的存储单元！
                    2：每声明一个结构体变量，系统即分配一段这样的内存块；

            结构体指针：
                1：结构体指针指的是某个结构体变量在内存中的地址；
                2：声明方式：struct 结构体名 *指针变量名;
                3：一些注意事项：
                    数组名和结构体名的不同：
                        1：对于数组而言，数组名在sizeof,&取地址运算符，以及数组声明时代表的是整个数组，除此之外只能代表数组的首地址；
                        2：结构体变量名，无论何时，都代表结构体所有成员！
                    数组指针和结构体指针的不同：
                        1：数组指针指的是指向数组中某一个元素的指针！
                        2：结构体指针指的是整个结构体成员！
                    特别注意：结构体指针指的是指向某个结构体变量的指针，并非结构体本身的指针，结构体本身只是一种数据集合的模板，并不占内存，因此不存在指向结构体本身的指针！

            结构体数组：
                仍然是一个数组，只不过数组的每一项都是一个结构体(指针)！
            
            结构体操作：
                取值:1：结构体变量名.结构体成员名
                     2：结构体指针变量名->结构体成员名
                     3：*(结构体指针变量名).结构体成员名

                赋值:1：结构体变量名.结构体成员名 = 值
                     2：结构体指针变量名->结构体成员名 = 值
                     3：(*结构体指针变量名).结构体成员名 = 值
            
            结构体占用内存空间的大小：
                1：结构体中每一个成员在内存中的存储是连续且有序的；
                2：结构体占用内存空间的大小有可能是结构体中每个成员的数据类型在当前平台占用内存大小的总和；但是由于内存对齐的原因也有可能大于总和！
                3：内存对齐：
                    1：计算机内存被分割为1字节大小的多个存储单元，理论上cpu可以访问任意编号的存储单元，无论该存储单元是否有权限！
                    2：实际上cpu通过地址总线来访问内存，一次能处理几个字节的数据，就命令地址总线读取几个字节的数据(32位平台的cpu一次可以处理4个字节的数据，64位平台的cpu一次可以处理8个字节的数据)；每次可以读取的字节个数称之为步长！
                    3：将一个数据尽量放在一个步长之内，避免跨步长存储，CPU即可一次读取到需要的数据，可以提高数据读取效率，这称为内存对齐；
                    4：在32位平台默认以4字节对齐，在64位平台默认以8字节对齐；
                    5：c语言编译器为了提高数据的存取效率会自动根据平台进行内存对齐；因此会出现结构体存在存储缝隙的现象；出于该原因，结构体的大小是有可能大于结构体成员数据类型在该平台占用字节的总和！
                    6：示例：
                        struct tmp {
                            char name[8];
                            int length;
                        };
                        该结构体在win32位平台下，sizeof的值是12；
                        struct tmp {
                            char name[10];
                            int length;
                        };
                        该结构体在win32位平台下，sizeof的值是16；多出的两个字节是由于32位平台内存以4字节对齐，前10个字节刚好差两个字节成功成为4的倍数，实现4字节对齐，因此name数组和length之间就存在两个字节的缝隙；  
                    7：由于内存对齐的原因，结构体在声明时要特别注意不同数据类型成员之间的顺序！
                4：结构体占用空间大小的计算，需要使用sizeof获取结构体变量的大小，由于结构体本身只是模板，因此对结构体本身使用sizeof将会报错；

        共用体:
            1：共用体：
                1：共用体也是一种数据集合模板，但并非数据类型；
                2：共用体中的多个成员在共用体变量中共享同一段存储空间；
                3：共用体本身不是数据类型，只是一种数据结构模板，因此共用体本身不占用存储空间；

            2：共用体和结构体：
                相同点：
                    共用体和结构体都是一种数据结构模板，并非数据类型，不占用内存空间，可以通过名称来管理数据；
                不同点：
                    结构体：
                        1：结构体在分配存储空间时，会按照结构体中的每一个成员的数据类型在当前平台占用的字节大小分配存储空间，即结构体占用空间的大小大于等于每一个成员占用空间的大小；
                        2：结构体中每一个成员有自己的存储空间；
                    共用体：
                        1：共用体在分配存储空间时，只会按照占用空间最大的数据类型来分配，即结构体占用空间的大小等于占用空间最大的成员所占用的空间大小；
                        2：所有的成员共享一段存储空间，并且同一时刻只允许存储一个成员的数据；如果对新成员赋值，就会覆盖掉原来成员的值；

            3：共用体声明：
                union 共用体名{
                    数据类型  成员名;
                    数据类型  成员名;
                         .
                         .
                }
                
            4：共用体占用内存空间大小：
                1：共用体中，由于各个成员共享同一段内存空间，因此一个共用体变量占用的内存大小是：共用体成员中占用内存空间最大的成员所占用的内存空间；如：
                    union data{
                        int    score;
                        char   name;
                        double id
                    };
                    union data a;
                    a变量是一个共用体类型的变量，该共用体中占用空间最大的是double类型的成员id;因此整个共用体占用的内存空间大小为8个字节；

                2：共用体使用了内存覆盖技术，同一时刻只能存在一个共用体成员：
                    即声明一个共用体变量，编译器将会为该共用体申请一段内存空间，这段内存空间的大小是共用体中占用空间最长的成员的长度，这段内存空间同一时刻只能允许设置一个成员的值，为共用体成员每次设置新值的时候都会从某一端开始设置值；因此如果对共用体变量重新赋了值，那么原来的值将会收影响；
                    
            5：共用体的应用：
                共用体可以用在多个成员大小相近，业务类型相似，但又不可能同时存在的情况下；
            
        位域：
            1：有些情况下，存储数据并不需要一个或者多个完整的字节，只需要占用一个或者几个二进制位即可，C语言针对这种情况提供了位域这种数据结构；更加节省内存空间！
            2：位域并不是一个单独的数据结构，而是在声明结构体的时候用来指明某个成员变量所占用的二进制位数的！如：
                struct bs{
                    unsigned int  m;
                    unsigned int n:4;
                    unsigned char ch:6;
                }
                说明：
                    1：使用位域时，在成员名称后面通过冒号 : 限制该成员占用的二进制位数；
                    2：如果成员没有使用位域，那么会按照成员的数据类型为成员分配存储空间；
                    3：如果成员使用了位域，那么将会按照其占据的二进制位个数分配存储空间，位域的大小不能超过成员数据类型在当前平台所占据的二进制位个数；
                    4：C语言标准中，只有int、unsigned int支持位域，但实际编译器中，char、unsigned char、以及enum类型均有支持

            3：位域的存储：
                C语言标准并未规定位域的存储方式，不同的编译器有不同的实现，但是都会尽量压缩存储空间；
                1：具体规则如下：(重要)
                    1：当相邻成员类型相同时，
                        1：如果他们的位宽之和小于类型的sizeof大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；
                        2：如果他们的位宽之和大于类型的sizeof之和，那么后面的成员将从新的存储单元开始存储，其偏移量为类型在当前平台的字节数大小的整数倍！
                        3：特别注意：位域的sizeof值是内存对齐之后所占用内存大小的值(至少4/8字节或者为其整数倍)！

                    2：当相邻成员的类型不同时，不同的编译器有不同的实现方案，GCC会压缩存储，VC/VS不会！
                    3：特别注意：位域成员往往不占用完整的字节，因此使用&取地址运算符获取位域成员地址没有任何意义，因为位域成员是以位为单位的，而地址则是字节的编号，不是位的编号！

            4：无名位域：
                1：位域成员可以没有名称，只给出数据类型和所占用的位宽；
                    如：
                        struct bs{
                            int m: 12;
                            int  : 20;  //该位域成员不能使用
                            int n: 4;
                        };
                2：无名位域一般用来做填充或者调整成员位置；因为没有名称，无名位域不能使用；
            
                
十二：常量：
    1：在C语言中，常量是指一旦被声明并初始化完成之后，就不能再修改值的量；
    2：C语言中通过const关键字修饰变量来得到常量！
    3：const的使用方式：
        1：创建一个常量：const 数据类型名称 变量名称 = 值;
        2：将一个变量修饰为常量：const 变量名；
        3：将函数形参修饰为常量：为防止函数中修改形参数值，可以将函数形参修饰为常量：const 数据类型名 形参名称
    4：几种const使用方式的注意事项：
        1：const要求在声明常量时即初始化，否则将无法再赋值；
        2：const如果修饰已经完成初始化普通的变量，在完成const修饰之后，该变量本身的值将不能再被修改；
        3：const如果修饰指针变量，一般有一下三种形式：
            1：const要求在声明变量时即初始化，否则将无法再赋值；
            2：const来修饰普通变量，则该变量将不能再重新赋值；使用方式：const type var_name = value;
            3：const来修饰指针变量，则有三种情况：
                情况1：const 修饰的是指针符号和变量名，那么指针变量所指向的内存空间中的值不能被修改；指针变量本身可以修改指向不同的内存空间！如：
                    const int *pointer;
                    int const *pointer;
                情况2：const 修饰的是变量名，不包括指针符号，那么指针变量本身不能修改，即指针变量不能再被修改指向其他内存空间：
                    int * const pointer;
                情况3：const 既修饰指针又修饰变量，则指针变量本身不能再被修改，即指针变量不能再被修改为指向其他内存空间，且指针变量指向的内存空间中的值也不能再改变！
                    int const * const pointer

十三：为数据类型定义别名：
    C语言中可以通过typedef 数据类型名称 newname的方式来为特定的数据类型定义别名；
    1：为基本数据类型定义别名：
        如：声明：typedef int INTEGER;  那么INTEGER就代表int类型的数据
            使用：INTEGER 1;            等价于int i;
    2：为数组类型定义别名：
        如：声明：typedef char newname[20];  那么newname就等同于一个char类型长度为20的数组；
            使用：newname a1,a2;             等价于char a1[20],a2[20]
    3：为结构体定义别名：
        如：声明：typedef struct stu{
                    char  *name;
                    short age;
                 } STU;                     那么STU就代表stu结构体；
            使用：STU stu1;                  等价于struct stu stu1；

十四：函数：
    1：函数即声明的代码块，c代码文件中可以有任意多个函数；
    2：函数的声明：
        返回值类型/void function_name(int a, int b){
                code....
        }
        备注：  
            1：函数声明要注明返回值类型，没有返回值时要写void；
            2：函数名要遵守c语言标识符命名规范；推荐以小写加下划线方式命名；
            3：形参需要通过数据类型 变量的方式声明，多个形参使用,隔开；如果为了防止形参在函数中被修改，可以使用const关键字将形参修饰为常量；
            4：在函数体中使用return语句返回数据。
    3：形参：
        1：形参是函数在调用时必须传入的参数，要写在()中；每一个形参要注明数据类型和名称；多个形参以 , 分割；
        2：C语言中形参不允许赋初值；
        3：形参和实参在数量上，顺序上，类型上必须严格一致；
        4：函数调用中参数传递是单向的，即：只能将实参的值赋值给形参，形参实际是实参的拷贝，因此，形参的值发生改变并不会影响实参的值；
        5：形参的生命周期：
            1：形参只有在函数调用时才会分配存储空间，调用结束之后，会立刻释放所占用的存储空间；
            2：对于形参占用空间的释放，本质上只是弃之不用，并非清空；
            3：对于指针类型的形参，函数执行结束之后，将会销毁指针类型形参变量的值，但是该指针所指向的存储空间中的内容并不会销毁；
        6：对于函数需要传入数组，结构体，函数，字符串等复杂的数据类型时，推荐传入指针；

    4：函数的返回值：
        1：通过return语句返回：即：return 表达式;并且一个函数中可以使用多个return，但是第一个return返回之后函数即结束；
        2：通过全局变量接收返回值：即：声明一个全局变量，将函数的返回值赋值为全局变量，调用者调用完函数之后，可以通过全局变量获得返回值；
        3：通过指针变量获取返回值：即为函数设置一个指针类型的形参，并赋值为接收返回结果的指针变量，在函数中将返回值赋值给该指针变量指向的存储空间；在调用函数中可以通过该实参指针变量获取返回值；

    5：函数调用：
        1：函数调用：函数名(实参) 即可调用；如果函数有返回值则可以使用变量接收返回值；如果没有返回值则不要使用变量接收函数调用的结果；
        2：c语言的执行逻辑是从main函数开始执行，而且是依次从上往下逐条执行；原则上函数的定义要出现在函数的调用之前；否则将会报错；
        3：如果函数在定义之前需要使用则需要先对函数进行声明；

    6：函数的声明：
        1：声明格式：返回值类型 函数名 （类型 形参，类型 形参,...）;或者返回值类型 函数名 （类型,类型,...）;
        2：在函数调用之前有了函数的声明，函数实体将可以出现在任何地方，可以在其他文件，静态链接库，动态链接库；

    7：递归：
        1：函数中自己调用自己的过程称为递归；
        2：在函数中每递归一次，就等同于从新调用一次该函数；
        3：基于第二条，因此在递归中每递归一次，函数被调用一次，函数所使用到的局部变量都将被重新创建一次；并放在调用栈中！递归完成之后将会按照调用栈层层返回；
        4：基于第三条：递归的调用速度是低于循环的，而且占用额外的内存空间；并且递归的深度取决于内存的大小；
        5：尾递归：函数的递归放置在最后一行，即：函数调用完自身后，原函数即结束，这样的递归称之为尾递归；
        6：尾递归的优势：基于2~3条，函数的递归深度取决于内存的大小，如果递归深度过深将会超过内存限制而出错！如果是尾递归，函数每进行下一次新的调用，上一次的函数执行即结束，函数调用栈中永远只有一个函数，不会超过内存限制！

    8：函数指针：
        1：函数在程序运行时，代码也被加载至内存中，并占用一段连续的存储单元；
        2：可以定义一个指针变量，指向存储函数代码的内存块的地址，通过该指针变量即可找到函数的内容，进而调用函数；这样的指针称之为函数指针，指针变量称之为函数指针变量；
        3：函数指针的声明形式：
            returnType (*pointerName)(param list)
            备注：
                1：returnType指的是该函数的返回值类型；
                2：pointerName是函数指针变量的名称；*pointerName指明该变量是一个指针类型的；(* pointerName)中的()必须带上！
                3：param list是函数的形参列表；
        4：函数指针的调用：
            (*pointerName)(实参列表);
            形态说明：
                *表名对pointerName的指针变量进行调用，由于()的运算优先级最高，所以*和pointerName必须使用()运算符，否则语义将会改变！
    9：c语言中的标准函数库：       
        基本库：<stdio.h>、<ctype.h>、<stdlib.h>、<string.h>、<time.h>
        常用库：<assert.h>、<limits.h>、<stddef.h>、
        其他库：<float.h>、<math.h>、<error.h>、<locale.h>、<setjmp.h>、<signal.h>、<stdarg.h>  
                
                


                    


                



                                          

                


                


                

                



